<html><head><title>Mandelbox rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Scale factor */
uniform float uScale;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

const vec3 LIGHT = vec3(0.707, 0.707, 0.);
const vec3 UP = vec3(0.0, 0.0, 1.0);
const int ITERATIONS = 20;
const int AOITERATIONS = 8;
const int RAYITERATIONS = 256;
const float DETAIL = 0.002;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return vec3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}

float mandelboxDistance(in vec3 pos) {
    vec3 iter = pos;
    float scale = uScale;

    for (int i = 0; i < ITERATIONS; i ++) {
	/* Box fold */
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	iter *= uScale / f;
	scale *= uScale / f;
	iter += pos;
    }

    iter = abs(iter);
    return max(iter.x, max(iter.y, iter.z)) / abs(scale);
}

float mandelboxColor(in vec3 pos, out vec3 iter) {
    iter = pos;
    float scale = uScale;

    float coloringType = 1.0;
    for (int i = 0; i < ITERATIONS; i ++) {
	/* Box fold */
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	iter *= uScale / f;
	scale *= uScale / f;
	iter += pos;
	coloringType = min(coloringType, f);
    }
    coloringType -= 0.25;
    coloringType /= 0.75;
    return coloringType;
}

float intersectMandelbox(in vec3 pos, in vec3 dir)
{
    float t = 0.;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	float dt = mandelboxDistance(pos + t * dir);
	t += dt;

	/* World scale small enough? */
        if (dt < DETAIL * t) {
	    break;
	}
	/* Out of known bounding volume */
	if (t > 10.) {
	    break;
	}
    }
    return t;
}

vec3 getMandelboxColor(in vec3 pos, in vec3 dir) {
    float t = intersectMandelbox(pos, dir);
    if (t > 10.) {
	return dir * .01 + vec3(1.0, 1.0, 1.0) * smoothstep(0.998, 0.999, dot(dir, LIGHT));
    }
    pos += t * dir;
    float dt = t * DETAIL;

    /* Gradient of the hit point */
    float dx1 = mandelboxDistance(pos + vec3(-dt, 0., 0.));
    float dy1 = mandelboxDistance(pos + vec3(0., -dt, 0.));
    float dz1 = mandelboxDistance(pos + vec3(0., 0., -dt));
    float dx2 = mandelboxDistance(pos + vec3(dt, 0., 0.));
    float dy2 = mandelboxDistance(pos + vec3(0., dt, 0.));
    float dz2 = mandelboxDistance(pos + vec3(0., 0., dt));
    vec3 norm = normalize(vec3(dx2 - dx1, dy2 - dy1, dz2 - dz1));

    /* World-space ambient occlusion from the 8 corners of the cube. */
    float ao = 0.0;
    vec3 disp = vec3(dt, dt, dt) * 8.;
    float expected = length(disp);
    for (int i = 0; i < AOITERATIONS; i ++) {
	float actual = mandelboxDistance(pos + disp);
	/* Typically the distance is underestimated.
	 * The 2. is a fudge factor for how much. */
	ao += min(1., 2. * actual / expected);
	/* flip x on every coord */
	disp.x = -disp.x;
	/* flip y on every 2nd */
	if (i == 1 || i == 3 || i == 5) {
	    disp.y = -disp.y;
	}
	/* flip z = every 4th */
	if (i == 3) {
	    disp.z = - disp.z;
	}
    }
    /* How large an angle do we need before we start to see AO?
     * I think something around /4 is alright (corresponds to 90 degrees).
     * The fudge factor above is probably not sufficient so this compensates. */
    ao = clamp(ao / float(AOITERATIONS / 4), 0., 1.);

    /* Calculate diffuse and specular terms. */
    float diffuse = max(dot(LIGHT, norm), 0.2);
    vec3 reflection = reflect(LIGHT, norm);
    float specular = max(dot(reflection, dir), 0.);

    /* Estimate material type. */
    vec3 iter;
    float curveLike = mandelboxColor(pos, iter);
    vec3 color = iter / length(iter) * .5 + vec3(.5, .5, .5);
    color = mix(color, vec3(1., 1., 1.), curveLike);

    //color = vec3(1., 1., 1.);
    //diffuse = 1.;
    //ao = 1.0;
    //specular = 0.;
    //t = 0.;

    return (color * (diffuse * ao) + .25 * pow(specular, 64.)) / (1. + t * t * .1);
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    vec3 color = getMandelboxColor(uPos, dir);
    gl_FragColor = vec4(sqrt(color), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    effectPos(0., 8., 0.);

    shader.uScale = gl.getUniformLocation(shader, "uScale");
    var scale = document.getElementById("scale");
    scale.onchange = function() {
	gl.uniform1f(shader.uScale, parseFloat(this.value));
    };
    scale.onchange();
    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Mandelbox</h1>
<form onsubmit="return false">
Scale: <input type="text" id="scale" value="2.0" size="4" />
</form>
<canvas id="canvas" width="768" height="768"></canvas>

</body>
</html>
