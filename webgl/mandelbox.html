<html><head><title>Mandelbox rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Scale factor */
uniform float uScale;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

const vec3 LIGHT = vec3(0.707, 0.707, 0.);
const vec3 UP = vec3(0.0, 0.0, 1.0);
const int ITERATIONS = 20;
const int RAYITERATIONS = 256;
const float DETAIL = 0.002;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return vec3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}

float mandelboxDistance(in vec3 pos) {
    vec3 iter = pos;
    float scale = uScale;

    for (int i = 0; i < ITERATIONS; i ++) {
	/* Box fold */
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	iter *= uScale / f;
	scale *= uScale / f;
	iter += pos;
    }

    return sqrt(dot(iter, iter)) / abs(scale);
}

float mandelboxColor(in vec3 pos) {
    vec3 iter = pos;
    float scale = uScale;

    float coloringType = 1.0;
    for (int i = 0; i < ITERATIONS; i ++) {
	/* Box fold */
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	iter *= uScale / f;
	scale *= uScale / f;
	iter += pos;
	coloringType = min(coloringType, f);
    }
    coloringType -= 0.25;
    coloringType /= 0.75;
    return coloringType;
}

float intersectMandelbox(inout vec3 pos, in vec3 dir)
{
    float t = 0.;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	float distance = mandelboxDistance(pos);
        pos += distance * dir;
	t += distance;

        if (distance < DETAIL * t) {
	    break;
	}
	if (t > 10.) {
	    break;
	}
    }
    return t;
}

vec3 getMandelboxColor(in vec3 pos, in vec3 dir, out float t) {
    t = intersectMandelbox(pos, dir);
    if (t > 10.) {
	return dir * .1 + vec3(1.0, 1.0, 1.0) * smoothstep(0.998, 1.0, dot(dir, LIGHT));
    }

    /* Estimate material type. */
    float curveLike = mandelboxColor(pos);
    float boxLike = 1. - curveLike;

    /* Calculate normal. */
    float dt = DETAIL * t;
    float distance = mandelboxDistance(pos);
    float dx = mandelboxDistance(pos + vec3(dt, 0., 0.));
    float dy = mandelboxDistance(pos + vec3(0., dt, 0.));
    float dz = mandelboxDistance(pos + vec3(0., 0., dt));
    vec3 norm = normalize(vec3(dx, dy, dz) - distance);

    float ao = 1.0;
    for (int i = 3; i < 6; i ++) {
	float expected = dt * pow(2.0, float(i));
	float actual = mandelboxDistance(pos - dir * expected);
	ao *= min(1.0, 2.0 * actual / expected);
    }

    /* Calculate diffuse and specular terms. */
    float diffuse = max(dot(LIGHT, norm), 0.);
    vec3 reflection = reflect(LIGHT, norm);
    float specular = max(dot(reflection, dir), 0.);

    vec3 color = vec3(1. - boxLike, 1. - max(curveLike, boxLike), 1. - curveLike);
    return (color * ao * diffuse) + .2 * pow(specular, 64.0);
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 pos = vec3(0., 8., 0.) + uPos;
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    float distance;
    vec3 color = getMandelboxColor(pos, dir, distance);
    gl_FragColor = vec4(sqrt(color), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    shader.uScale = gl.getUniformLocation(shader, "uScale");
    var scale = document.getElementById("scale");
    scale.onchange = function() {
	gl.uniform1f(shader.uScale, parseFloat(this.value));
    };
    scale.onchange();
    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Mandelbox</h1>
<form onsubmit="return false">
Scale: <input type="text" id="scale" value="2.0" size="4" />
</form>
<canvas id="canvas" width="512" height="512"></canvas>

</body>
</html>
