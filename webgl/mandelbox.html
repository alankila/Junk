<html><head><title>Mandelbox rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Scale factor */
uniform float uScale;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

const vec3 LIGHT = vec3(0.707, 0.707, 0.);
const vec3 UP = vec3(0.0, 0.0, 1.0);
const int ITERATIONS = 20;
const int RAYITERATIONS = 256;
const float DETAIL = 0.002;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return vec3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}

float mandelboxDistance(in vec3 pos) {
    vec3 iter = pos;
    float scale = uScale;

    for (int i = 0; i < ITERATIONS; i ++) {
	/* Box fold */
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	iter *= uScale / f;
	scale *= uScale / f;
	iter += pos;
    }

    return sqrt(dot(iter, iter)) / abs(scale);
}

float mandelboxColor(in vec3 pos, out vec3 iter) {
    iter = pos;
    float scale = uScale;

    float coloringType = 1.0;
    for (int i = 0; i < ITERATIONS; i ++) {
	/* Box fold */
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	iter *= uScale / f;
	scale *= uScale / f;
	iter += pos;
	coloringType = min(coloringType, f);
    }
    coloringType -= 0.25;
    coloringType /= 0.75;
    return coloringType;
}

float intersectMandelbox(in vec3 pos, in vec3 dir)
{
    float t = 0.;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	float dt = mandelboxDistance(pos + t * dir);
	t += dt;

	/* World scale small enough? */
        if (dt < DETAIL * t) {
	    break;
	}
	/* Out of known bounding volume */
	if (t > 10.) {
	    break;
	}
    }
    return t;
}

vec3 getMandelboxColor(in vec3 pos, in vec3 dir) {
    float t = intersectMandelbox(pos, dir);
    if (t > 10.) {
	return dir * .01;
	// + vec3(1.0, 1.0, 1.0) * smoothstep(0.998, 0.999, dot(dir, LIGHT));
    }
    pos += t * dir;
    float dt = t * DETAIL;

    /* Gradient around the set */
    /*
    float dx1 = mandelboxDistance(pos + vec3(-dt, 0., 0.));
    float dy1 = mandelboxDistance(pos + vec3(0., -dt, 0.));
    float dz1 = mandelboxDistance(pos + vec3(0., 0., -dt));
    float dx2 = mandelboxDistance(pos + vec3(dt, 0., 0.));
    float dy2 = mandelboxDistance(pos + vec3(0., dt, 0.));
    float dz2 = mandelboxDistance(pos + vec3(0., 0., dt));
    vec3 norm = normalize(vec3(dx2 - dx1, dy2 - dy1, dz2 - dz1));
    */

    /* because ao is estimated along the view ray,
     * we approximate diffuse lighting at the same time */
    float ao = 1.0;
    for (int i = 3; i < 7; i ++) {
	float expected = dt * pow(2.0, float(i));
	float actual = mandelboxDistance(pos - dir * expected);
	ao *= min(1.0, 2. * actual / expected);
    }

    /* Calculate diffuse and specular terms. */
    /*
    float diffuse = max(dot(LIGHT, norm), 0.);
    vec3 reflection = reflect(LIGHT, norm);
    float specular = max(dot(reflection, dir), 0.);
    */

    /* Estimate material type. */
    vec3 iter;
    float curveLike = mandelboxColor(pos, iter);
    vec3 color = vec3(.5, .5, .5) + iter / length(iter) * .5;
    color = mix(color, 1. - color * .5, curveLike);

    return color * ao / (1. + t * t * .01);
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    vec3 color = getMandelboxColor(uPos, dir);
    gl_FragColor = vec4(sqrt(color), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    effectPos(0., 8., 0.);

    shader.uScale = gl.getUniformLocation(shader, "uScale");
    var scale = document.getElementById("scale");
    scale.onchange = function() {
	gl.uniform1f(shader.uScale, parseFloat(this.value));
    };
    scale.onchange();
    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Mandelbox</h1>
<form onsubmit="return false">
Scale: <input type="text" id="scale" value="2.0" size="4" />
</form>
<canvas id="canvas" width="512" height="512"></canvas>

</body>
</html>
