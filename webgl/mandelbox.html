<html><head><title>Mandelbox rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Scale factor */
uniform float uScale;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

const vec3 LIGHT = vec3(0.707, 0.707, 0.);
const vec3 UP = vec3(0.0, 0.0, 1.0);
const int ITERATIONS = 16;
const int RAYITERATIONS = 256;
const float DETAIL = 0.0025;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return vec3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}

float mandelboxDistance(in vec3 pos, out float coloringType) {
    vec3 iter = pos;
    float DEfactor = uScale;

    coloringType = 0.;
    for (int i = 0; i < ITERATIONS; i ++) {
	iter = clamp(iter, -1., 1.) * 2. - iter;
	float f = clamp(dot(iter, iter), 0.25, 1.0);
	float mf = uScale / f;
	iter = iter * mf + pos;
	coloringType += f;
	DEfactor *= mf;
    }
    coloringType /= float(ITERATIONS);

    return length(iter) / abs(DEfactor);
}

void intersectMandelbox(inout vec3 pos, in vec3 dir, out float t, out int iterations)
{
    t = 0.;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	float discardColor;
	float distance = mandelboxDistance(pos, discardColor);

        pos += distance * dir;
	t += distance;
	float dt = DETAIL * t;
        if (distance < dt) {
	    iterations = j;
	    return;
	}

	if (t > 10.) {
	    break;
	}
    }

    iterations = RAYITERATIONS;
}

vec3 getMandelboxColor(in vec3 pos, in vec3 dir, out float t) {
    int ao;
    intersectMandelbox(pos, dir, t, ao);
    if (t != 1.) {
	/* Estimate material type. */
	float curveLike;
	float distance = mandelboxDistance(pos, curveLike);
	curveLike = pow(curveLike, 8.);
	float boxLike = 1. - curveLike;
	float metallicness = boxLike * curveLike * 4.;

	/* Calculate normal. */
	float discardColor;
	float dt = DETAIL * t;
	float dx = mandelboxDistance(pos + vec3(dt, 0., 0.), discardColor);
	float dy = mandelboxDistance(pos + vec3(0., dt, 0.), discardColor);
	float dz = mandelboxDistance(pos + vec3(0., 0., dt), discardColor);
	vec3 norm = normalize(vec3(dx, dy, dz) - distance);

	/* Calculate diffuse and specular terms. */
	float diffuse = max(dot(LIGHT, norm), 0.);
	float aoTerm = 1. - float(ao) / float(RAYITERATIONS);
	vec3 reflection = reflect(LIGHT, norm);
	float specular = max(dot(reflection, dir), 0.);

	/* Calculate shadow. */	
	float lightDistance;
	int lightAo;
	pos += LIGHT * dt;
	intersectMandelbox(pos, LIGHT, lightDistance, lightAo);
	lightDistance /= 10.;

	vec3 color = vec3(1. - boxLike, 1. - max(curveLike, boxLike), 1. - curveLike);
	return
	    (color * (.1 * aoTerm + diffuse * lightDistance)
	     + metallicness * pow(specular, 1. + 50. * metallicness) * lightDistance) / (1. + t * t * .2);
    }
    
    return vec3(0., 0., 0.);
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 pos = vec3(0., 8., 0.) + uPos;
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    float distance;
    vec3 color = getMandelboxColor(pos, dir, distance);
    vec3 space = dir * .1 + vec3(1.0, 1.0, 1.0) * smoothstep(0.998, 1.0, dot(dir, LIGHT));
    gl_FragColor = vec4(sqrt(mix(color, space, step(9.9, distance))), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    shader.uScale = gl.getUniformLocation(shader, "uScale");
    var scale = document.getElementById("scale");
    scale.onchange = function() {
	gl.uniform1f(shader.uScale, parseFloat(this.value));
    };
    scale.onchange();
    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Mandelbox</h1>
<form onsubmit="return false">
Scale: <input type="text" id="scale" value="2.0" size="4" />
</form>
<canvas id="canvas" width="768" height="768"></canvas>

</body>
</html>
