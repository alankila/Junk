<html><head><title>Mandelbulb rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Coordinates being currently rendered. */
varying vec2 vPosition;

const int RAYITERATIONS = 256;

const vec3 UP = vec3(0., 0., 1.);

const vec3 LIGHT = vec3(0.707, 0., 0.707);

const int ITERATIONS = 16;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

float testPoint(vec3 c, inout float orbit) {
    vec3 z = c;

    // Iterate to compute the distance estimator.
    int iterations = ITERATIONS;
    float zl;
    for (int i = 0; i < ITERATIONS; i ++) {
	vec3 z2 = z * z;
	vec3 z4 = z2 * z2;

	float k3 = z2.x + z2.z;
	float k5 = z2.x * z2.z;
	float k1 = z4.x + z4.y + z4.z - 6.0 * z2.y * k3 + 2.0*k5;
	float k4 = k3 - z2.y;
	float k2 = z.y * k4 * k1 * pow(k3, -3.5);

	z = c + vec3(
	    64.0*k2*z.x*z.z*(z2.x-z2.z)*(z4.x-6.0*k5+z4.z),
	    -16.0*z2.y*k3*k4*k4 + k1*k1,
	    -8.0*k2*(z4.x * (z4.x - 28.0*k5) + 
		z4.z * (70.0*z4.x - 28.0*k5 + z4.z))
	);

	zl = dot(z, z);
	if (zl < orbit) {
	    orbit = zl;
	}

	if (zl > 4.) {
	    iterations = i;
	    break;
	}
    }
   
    // Return the distance estimation value which determines the next raytracing
    // step size, or if whether we are within the threshold of the surface.
    return .5 * log(zl) / pow(8., float(iterations));
}

vec3 intersectMandelbulb(inout vec3 pos, in vec3 dir) {
    float t = 0.1;
    float s = 0.001;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	/* Outside the fractal region? */
	if (dot(pos, pos) > 4.0) {
	    break;
	}

	float ao = 1., aoignore;
	float p  = testPoint(pos, ao);
	float ds = s*t*.5;
	float px = testPoint(pos + vec3(ds, 0., 0.), aoignore);
	float py = testPoint(pos + vec3(0., ds, 0.), aoignore);
	float pz = testPoint(pos + vec3(0., 0., ds), aoignore);
	vec3 d = (vec3(px, py, pz) - p) / ds;

	float distance = .5 * p / length(d);
        pos += distance * dir;
	t += distance;

	if (distance < s * t) {
	    d = normalize(d);
	    float diffuse = max(dot(d, LIGHT), 0.);
	    float specular = max(dot(reflect(LIGHT, d), dir), 0.);
	    float color = clamp(p / distance * .2, 0., 1.);
	    vec3 objColor = vec3(color, 2. * color * (1.-color), 1.-color);
	    return (objColor * diffuse * ao
		    + diffuse * pow(specular, 20.)) / (1. + t * t);
	}
    }

    return vec3(0., 0., 0.);
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 pos = vec3(0.1, 1.2, 0.) + uPos;
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    vec3 color = intersectMandelbulb(pos, dir);
    gl_FragColor = vec4(sqrt(color), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    effectStart(gl, shader);
}
</script>
</head>
<body>

<canvas id="canvas" width="800" height="800"></canvas>

</body>
</html>
