<html><head><title>Mandelbulb rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Coordinates being currently rendered. */
varying vec2 vPosition;

const int RAYITERATIONS = 256;
const float DETAIL = 0.001;

const vec3 UP = vec3(0., 0., 1.);

const vec3 LIGHT = vec3(0.707, 0., 0.707);

const int ITERATIONS = 7;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

float testPoint(vec3 c, out float orbit) {
    vec3 z = c;

    // Iterate to compute the distance estimator.
    int lastIteration = ITERATIONS - 1;
    float zl;
    orbit = 1.;
    for (int i = 0; i < ITERATIONS; i ++) {
	vec3 z2 = z * z;
	vec3 z4 = z2 * z2;

	float k3 = z2.x + z2.z;
	float k5 = z2.x * z2.z;
	float k1 = z4.x + z4.y + z4.z - 6.0*z2.y*k3 + 2.0*k5;
	float k4 = z.y * (z2.x - z2.y + z2.z);
	float k2 = -8. * k1 * pow(k3, -3.5) * k4;

	z = c + vec3(
	    -8.0*z.x*z.z*(z2.x-z2.z)*(z4.x-6.0*k5+z4.z)*k2,
	    -16.0*k3*k4*k4 + k1*k1,
	    (z4.x*z4.x - 28.0*k5*(z4.x+z4.z) + 70.0*z4.x*z4.z + z4.z*z4.z)*k2
	);

	zl = dot(z, z);
	if (zl < orbit) {
	    orbit = zl;
	}

	if (zl > 4.) {
	    lastIteration = i;
	    break;
	}
    }
 
    return 0.5 * log(zl) * pow(1./8., float(lastIteration));
}

vec3 intersectMandelbulb(in vec3 pos, in vec3 dir) {
    float t = 0.01;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	/* Outside the fractal region? */
	vec3 ipos = pos + dir * t;
	if (dot(ipos, ipos) > 4.0) {
	    break;
	}

	float ao;
	float p = testPoint(ipos, ao);
	float aoIgnore;
	float px = testPoint(ipos + vec3(DETAIL * t, 0., 0.), aoIgnore);
	float py = testPoint(ipos + vec3(0., DETAIL * t, 0.), aoIgnore);
	float pz = testPoint(ipos + vec3(0., 0., DETAIL * t), aoIgnore);
	vec3 g = (vec3(px, py, pz) - p) / (DETAIL * t);
	float distance = .5 * p / length(g);
	t += distance;

	if (distance < DETAIL * t) {
	    g = normalize(g);
	    float diffuse = max(0.3, dot(LIGHT, g));
	    vec3 color = abs(ipos) / length(ipos);
	    return (color * diffuse * ao) * exp(-t);
	}
    }

    return dir * .1 + smoothstep(0.998, 0.999, dot(dir, LIGHT));;
}

vec3 intersectSphere(vec3 pos, vec3 dir, vec3 center, float radius) {
    vec3 toSphereCenter = center - pos;
    vec3 sphereCenterOnRay = pos + dir * dot(toSphereCenter, dir);
    vec3 toCenterFromProjection = center - sphereCenterOnRay;
    float squaredDistance = dot(toCenterFromProjection, toCenterFromProjection);

    /* No intersection. */
    if (squaredDistance > radius * radius) {
	return pos;
    }

    float distanceInsideSphere = sqrt(radius * radius - squaredDistance);
    vec3 intersectPoint = sphereCenterOnRay - distanceInsideSphere * dir;

    /* Are we already inside sphere? */
    if (dot(intersectPoint - pos, dir) < 0.) {
	return pos;
    }

    return intersectPoint;
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    vec3 pos = intersectSphere(uPos, dir, vec3(0., 0., 0.), 2.);
    vec3 color = intersectMandelbulb(pos, dir);
    gl_FragColor = vec4(sqrt(color), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    effectPos(0.1, 1.2, 0.);
    effectStart(gl, shader);
}
</script>
</head>
<body>

<canvas id="canvas" width="800" height="800"></canvas>

</body>
</html>
