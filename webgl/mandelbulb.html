<html><head><title>Mandelbulb rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Coordinates being currently rendered. */
varying vec2 vPosition;

const int RAYITERATIONS = 256;

const vec3 UP = vec3(0., 0., 1.);

const vec3 LIGHT = vec3(0.707, 0., 0.707);

const int ITERATIONS = 16;

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

float testPoint(vec3 c, inout float orbit) {
    vec3 z = c;

    // Iterate to compute the distance estimator.
    int iterations = ITERATIONS;
    float zl;
    for (int i = 0; i < ITERATIONS; i ++) {
	vec3 z2 = z * z;
	vec3 z4 = z2 * z2;

	float k3 = z2.x + z2.z;
	float k32 = k3 * k3;
	float k34 = k32 * k32;
	float k2 = inversesqrt(k34 * k32 * k3);
	float k1 = z4.x + z4.y + z4.z - 6.0*z2.y*z2.z - 6.0*z2.x*z2.y + 2.0*z2.z*z2.x;
	float k4 = z2.x - z2.y + z2.z;

	z = c + vec3(
	    64.0*z.x*z.y*z.z*(z2.x-z2.z)*k4*(z4.x-6.0*z2.x*z2.z+z4.z)*k1*k2,
	    -16.0*z2.y*k3*k4*k4 + k1*k1,
	    -8.0*z.y*k4*(z4.x*z4.x - 28.0*z4.x*z2.x*z2.z + 70.0*z4.x*z4.z - 28.0*z2.x*z2.z*z4.z + z4.z*z4.z)*k1*k2
	);

	zl = dot(z, z);
	if (zl < orbit) {
	    orbit = zl;
	}

	if (zl > 100.0) {
	    iterations = i;
	    break;
	}
    }
   
    // Return the distance estimation value which determines the next raytracing
    // step size, or if whether we are within the threshold of the surface.
    return .5 * log(zl) / pow(8., float(iterations));
}

vec3 intersectMandelbulb(inout vec3 pos, in vec3 dir) {
    float t = 0.1;
    float s = 0.0005;
    for (int j = 0; j < RAYITERATIONS; j ++) {
	/* Outside the fractal region? */
	if (dot(pos, pos) > 9.0) {
	    pos += dir;
	    t += 1.;
	    continue;
	}

	float ao = 1., aoignore;
	float p  = testPoint(pos, ao);
	float px = testPoint(pos + vec3(s, 0., 0.), aoignore);
	float py = testPoint(pos + vec3(0., s, 0.), aoignore);
	float pz = testPoint(pos + vec3(0., 0., s), aoignore);
	vec3 d = (vec3(px, py, pz) - p) / s;

	float distance = .5 * p / length(d);
        pos += distance * dir;
	t += distance;

	if (distance < s * t) {
	    d = normalize(d);
	    float diffuse = max(dot(d, LIGHT), 0.);
	    float specular = max(dot(reflect(LIGHT, d), dir), 0.);
	    float color = clamp(p / distance * .2, 0., 1.);
	    vec3 objColor = vec3(color, 2. * color * (1.-color), 1.-color);
	    return (objColor * diffuse * ao
		    + diffuse * pow(specular, 20.)) / (1. + t * t);
	}
    }

    return vec3(0., 0., 0.);
}

void main(void) {
    /* Calculate an orthonormal base for rendering. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);

    vec3 pos = vec3(0.1, 1.2, 0.) + uPos;
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);

    vec3 color = intersectMandelbulb(pos, dir);
    gl_FragColor = vec4(sqrt(color), 1.);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">
function effectInit(gl, shader) {
    effectStart(gl, shader);
}
</script>
</head>
<body>

<canvas id="canvas" width="512" height="512"></canvas>

</body>
</html>
