<html><head><title>Landscape rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Water texture */
uniform sampler2D uWatermap;
/* Noise texture */
uniform sampler2D uNoise;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

/* How far to subdivide modified Perlin noise.
 * (Determines how coarse the terrain is.) */
const int MAPITERATIONS = 8;
/* How many march iterations per ray. */
const int RAYITERATIONS = 256;
/* Convert distance between ray and terrain position to "safe" advancing step. */
const float MARCH_SPEED = 0.4;
/* Level Of Detail: how far to render until dropping terrain features. */
const float LOD = 2.0;
/* When ray reaches close enough to terrain, stop marching */
const float STOPCONDITION = 0.0025;
/* Render distance. */
const float FOG = 5.;
/* Water level */
const float WATER_LEVEL = 0.8;
/* Direction to infinitely far-away Sun */
const vec3 SUN = vec3(0.8, 0., 0.6);
/* Sun's brightness. */
const float SUN_INTENSITY = 8.;
/* The camera up direction. */
const vec3 UP = vec3(0., 0., 1.);

const vec2 F2 = vec2(0.366025403784, 0.366025403784);
const vec2 G2 = vec2(0.211324865405, 0.211324865405);
const float ONE = 1./256.;

/* This function is based on the work of John Davis and Stefan Gustavson. */
vec3 simplex2d(in vec2 P) {
    vec2 Pi = floor(P + dot(P, F2));
    vec2 Pf0 = P - Pi + dot(Pi, G2);

    // For the 2D case, the simplex shape is an equilateral triangle.
    // Find out whether we are above or below the x=y diagonal to
    // determine which of the two triangles we're in.
    vec2 o1 = vec2(Pf0.x > Pf0.y, Pf0.x <= Pf0.y);

    /* Get simplex gradients. The texture
     * contains 4 values per pixel, the rg pair being
     * gradient at (0, 0) and ba pair being the gradient at (1, 1).
     */
    Pi += .5;
    vec4 grad02 = texture2D(uNoise, Pi * ONE) * 2.0 - 1.0;
    vec2 grad0 = grad02.rg;
    vec2 grad1 = texture2D(uNoise, (Pi + o1) * ONE).rg * 2.0 - 1.0;
    vec2 grad2 = grad02.ba;

    vec2 Pf1 = Pf0 - o1 + G2;
    vec2 Pf2 = Pf0 + 2.0 * G2 - 1.0;
    vec3 t = max(0.5 - vec3(dot(Pf0, Pf0), dot(Pf1, Pf1), dot(Pf2, Pf2)), 0.);
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;

    vec3 td = t * t2 * vec3(dot(grad0, Pf0), dot(grad1, Pf1), dot(grad2, Pf2));
    float dx = 8. * dot(td, vec3(Pf0.x, Pf1.x, Pf2.x)) - dot(t4, vec3(grad0.x, grad1.x, grad2.x));
    float dy = 8. * dot(td, vec3(Pf0.y, Pf1.y, Pf2.y)) - dot(t4, vec3(grad0.y, grad1.y, grad2.y));

    // Sum up and scale the result to cover the range [-.5,.5]
    return vec3(dot(td, t), dx, dy) * 70.;
}

/* Combine simplex noise to given octave.
 * Output: vec4(normalx, normaly, normalz, value) */
vec4 fbmPerlin2d(in vec2 pos, in int maxLevel) {
    pos *= .25;
    float w = 0.5;
    vec3 o = vec3(w, 0., 0);
    for (int i = 0; i < MAPITERATIONS; i ++) {
        o += w * simplex2d(pos);
        if (i >= maxLevel) {
            break;
        }
        w *= .5;
        pos *= 2.;
    }
    
    return vec4(normalize(cross(vec3(-1., 0., o.y), vec3(0., -1., o.z))), o.x);
}

/* Combine simplex noise to given octave with enhancement by Inigo Quilez.
 * Output: value. */
float fbmQuilez2d(in vec2 pos, in int maxLevel) {
    pos *= .25;
    float w = 0.5;
    float o = w;
    vec2 d = vec2(0., 0.);
    for (int i = 0; i < MAPITERATIONS; i ++) {
        vec3 n = simplex2d(pos);
	d += n.yz * .3;
        o += w * n.x / (1. + dot(d, d));
        if (i >= maxLevel) {
            break;
        }
        w *= .5;
        pos *= 2.;
    }

    return o * 2.;
}

/* Combine simplex noise to given octave with enhancement by Inigo Quilez.
 * Output: normal. */
vec3 fbmQuilez2dNormal(in vec2 pos, in int maxLevel) {
    pos *= .25;
    float w = 0.5;
    vec2 o = vec2(0., 0.);
    vec2 d = vec2(0., 0.);
    for (int i = 0; i < MAPITERATIONS; i ++) {
        vec3 n = simplex2d(pos);
	d += n.yz * .3;
	o += w * n.yz / (1. + dot(d, d));
        if (i >= maxLevel) {
            break;
        }
        w *= .5;
        pos *= 2.;
    }

    o *= 2.;
    return normalize(cross(vec3(-1., 0., o.x), vec3(0., -1., o.y)));
}

/* Terrain marching.
 *
 * At each step along the way, the height of the ray from
 * ground is computed, and this is converted into a guesstimate
 * about a "safe" distance for ray to skip forwards.
 *
 * The octaves of Perlin noise that generates the landscape are
 * reduced if the ray appears to be far from the terrain, or
 * far from viewer.
 *
 * The stop condition also gets progressively coarser as
 * the ray gains distance to viewer. This should naturally "antialias"
 * the scenery at distance.
 *
 * Output: LOD value for terrain calculation.
 */
int intersectTerrain(inout vec3 pos, in vec3 dir, out float t) {
    /* Dynamic LOD during marching:
     * After distance to scene has been acquired, update LOD. */
    t = 0.0;
    int maxLevel = MAPITERATIONS;
    
    for (int i = 0; i < RAYITERATIONS; i ++) {
        float height = pos.z - fbmQuilez2d(pos.xy, maxLevel);

	/* There's a trick here. Our distance estimates are not conservative;
	 * if the ray steps into the terrain, height is negative, and the ray will
         * backtrack automatically. */
        float distanceEstimate = height * MARCH_SPEED;
        t += distanceEstimate;
        pos += distanceEstimate * dir;

	/* Dynamic level of detail. */
	float absHeight = abs(height);
        maxLevel = int(LOD / (absHeight * t));
        
        if (t > FOG) {
            break;
        }

        /* Are we close enough to terrain? */
        if (absHeight < STOPCONDITION * t) {
	    return maxLevel;
        }
	
	if (pos.z < WATER_LEVEL) {
	    return 1;
	}

    }

    t = FOG;
    return 0;
}

/* Evaluate rules to find color of terrain point.
 * Output: RGB. */
vec3 getTerrainColor(in vec3 pos, in vec3 dir, in int maxLevel) {
    /* Get surface properties. */
    vec3 normal = fbmQuilez2dNormal(pos.xy, maxLevel);
    vec4 noise = fbmPerlin2d(pos.xy * 64., 4);
    vec4 highfreqNoise = fbmPerlin2d(pos.xy * 1024., 3);

    /* Sand */
    vec4 terrain = vec4(1., 1., .5, 0.) * (.5 + .5 * highfreqNoise.w) * pos.z;
    vec3 terrainNormal = vec3(0., 0., 0.);

    /* Grass -- if terrain is not flat, the beach is shorter */
    float beachOrGrass = smoothstep(.75, .76, pos.z - normal.z * .1);
    vec4 grass = vec4(0.15, 0.3, 0.0, 0.) * highfreqNoise.w;
    terrain = mix(terrain, grass, beachOrGrass);

    /* Rock: two layers of texturing and normals:
     * first layer is coarse world-terrain noise
     * added to it is the same high-frequency noise
     * used for sand and grass */
    float greenOrBarren = smoothstep(.5, .6, pos.z - normal.z + noise.w * .2);
    float rockStripe = (noise.w - 0.3) * 1.5;
    rockStripe = rockStripe * rockStripe;
    vec4 rock = vec4(.3, .3, .3, .1) + highfreqNoise.w * highfreqNoise.w * highfreqNoise.w;
    terrain = mix(terrain, rock * rockStripe, greenOrBarren);
    vec3 rockNormal = noise.xyz + highfreqNoise.xyz;
    terrainNormal = mix(terrainNormal, rockNormal, greenOrBarren);

    /* Snow -- height increased if terrain is not flat. */
    float barrenOrSnow = smoothstep(2.5, 2.6, pos.z + normal.z + noise.w * .2);
    terrain = mix(terrain, vec4(1.4, 1.4, 1.4, .1), barrenOrSnow);
    terrainNormal = mix(terrainNormal, vec3(0., 0., 0.), barrenOrSnow);
   
    /* Apply lighting */
    float shadow = max(dot(normal, SUN), 0.);
    normal = normalize(normal + terrainNormal * .4);
    float diffuse = max(dot(normal, SUN), 0.1);
    vec3 reflection = 2. * normal * dot(SUN, normal) - SUN;

    return terrain.xyz * diffuse
	+ SUN_INTENSITY * terrain.w * pow(max(-dot(reflection, dir), 0.), 20.) * shadow;

}

/* Render sky.
 * Output: RGB.
 */
vec3 getSkyColor(in vec3 pos, in vec3 dir) {
    float sunAngle = max(dot(dir, SUN), 0.);
    float sunSpecular = pow(sunAngle, 40.);
    float skyBrightness = clamp(1. - dir.z, 0., 1.);
    float clouds = fbmPerlin2d(pos.xy + dir.xy * (8. - pos.z) / dir.z, 3).w;
    clouds *= clouds;
    return mix(vec3(skyBrightness, skyBrightness, 1.) * .8, vec3(1., 1., 1.), clouds * dir.z) * (1. + sunAngle)
	+ SUN_INTENSITY * sunSpecular;
}

/* Calculate water color based on reflection and refraction.
 * Output: RGB.
 */
vec3 getWaterColor(in vec3 pos, in vec3 dir) {
    /* Calculate water surface normal. */
    vec2 wave1 = texture2D(uWatermap, pos.xy * 1.7 + vec2(uTime *.07, 0.)).xy;
    vec2 wave2 = texture2D(uWatermap, pos.xy + vec2(0., uTime *.11)).xy;
    vec2 waves = wave1 - wave2;
    float waveStrength = dot(waves, waves);

    vec3 normal = vec3(waves, 1.0 - sqrt(waveStrength));

    /* Fresnel equation approximation */
    float reflectionOrRefraction = max(-dot(dir, normal), 0.);
    reflectionOrRefraction = sqrt(reflectionOrRefraction);
    vec3 reflection = dir - 2. * normal * dot(dir, normal);

    /* Reflect scenery */
    vec3 refpos = pos;
    float outLength; 
    int reflectionLevel = intersectTerrain(refpos, reflection, outLength);
    vec3 reflectedTerrain = getTerrainColor(refpos, reflection, reflectionLevel);

    /* Add sky */
    vec3 sky = getSkyColor(pos, reflection);
    reflectedTerrain = mix(reflectedTerrain, sky, outLength/FOG);

    /* Refract scenery (utterly fake). */
    float waterDepth = WATER_LEVEL - fbmQuilez2d(pos.xy, 4);
    pos.xy -= waves * waterDepth;
    pos.z = fbmQuilez2d(pos.xy, 4);
    vec3 refractedTerrain = getTerrainColor(pos, normal, 8);
    /* caustics */
    refractedTerrain *= 1. + min(0.1, waterDepth) * pow(wave1.x * wave2.y + 0.75, 20.);

    return mix(reflectedTerrain, refractedTerrain, reflectionOrRefraction);
}

/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

void main(void) {
    //gl_FragColor = texture2D(uWatermap, vPosition);
    //gl_FragColor = vec4(fbmPerlin2d(vPosition*4., 0) * vec3(1., 1., 1.), 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmPerlin2dNormal(vPosition*4., 0), 1.);
    //gl_FragColor = vec4(fbmQuilez2d(vPosition * 8., 8) * vec3(1., 1., 1.) * .5, 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmQuilez2dNormal(vPosition * 8., 8) * .5, 1.);
    //return;

    /* Calculate position of camera. */
    float groundHeight = fbmQuilez2d(uPos.xy, 2);
    if (groundHeight < WATER_LEVEL) {
	groundHeight = WATER_LEVEL;
    }
    vec3 cameraPos = vec3(uPos.xy, groundHeight + pow(2., -2.));
    
    /* Calculate an orthonormal basis based on lookat and up vector. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);
    
    /* Terrain march. */
    float distance;
    vec3 terrainPos = cameraPos;
    int maxLevel = intersectTerrain(terrainPos, dir, distance);

    /* Blend water if under water level. */
    vec3 terrain;
    if (terrainPos.z < WATER_LEVEL) {
	/* Backtrack to water surface. */
	float backtrackLength = (WATER_LEVEL - terrainPos.z) / dir.z;
	distance += backtrackLength;
	vec3 waterPos = terrainPos + dir * backtrackLength;
	terrain = getWaterColor(waterPos, dir);
    } else {
	terrain = getTerrainColor(terrainPos, dir, maxLevel);
    }

    /* Distance fog. */
    terrain = mix(terrain, vec3(.8, .8, .8), distance/FOG);

    /* Sky */
    if (distance / FOG == 1.) {
	terrain = getSkyColor(cameraPos, dir);
    }

    float exposureControl = 1. - max(dot(uDir, SUN), 0.) * (1. - 1./SUN_INTENSITY);
    gl_FragColor = vec4(sqrt(terrain * exposureControl), 1);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">

function prng(n) {
    n = (n ^ (n << 13)) & 0xffff;
    n = n * n;
    n ^= n << 5;
    return n ^ (n >> 7) & 0xffff;
}

function makeNoiseTexture(gl) {
    var pixels = new Uint8Array(256 * 256 * 4);
    var offset = 0;
    for (var i = 0; i < 256; i++) {
	for (var j = 0; j < 256; j++) {
	    var v1 = prng(j + prng(i) & 0xff);
	    var v2 = prng(j + 1 + prng(i + 1) & 0xff);
	    pixels[offset ++] = v1 & 0xff;
	    pixels[offset ++] = v1 >> 8;
	    pixels[offset ++] = v2 & 0xff;
	    pixels[offset ++] = v2 >> 8;
	}
    }
    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    return texture;
}

function makeWaterTexture(gl) {
    var waveParams = [];
    for (var wave = 0; wave < 20; wave ++) {
	var wp = prng(1234 ^ wave);
	waveParams.push([wp & 0xf, (wp >> 4) & 0xf, (wp >> 8) & 0xf, (1 + (wp >> 12) & 0xf) / 16 / 30]);
    }

    var pixels = new Uint8Array(512 * 512 * 4);
    var offset = 0;
    for (var i = 0; i < 512; i++) {
	var ifact = 2 * Math.PI * i / 512;
	for (var j = 0; j < 512; j++) {
	    var jfact = 2 * Math.PI * j / 512;

	    var m1 = 0;
	    var m2 = 0;
	    for (var wave = 0; wave < waveParams.length; wave ++) {
		var pa = waveParams[wave];
		var phase = ifact * pa[0] + jfact * pa[1] + pa[2];
		m1 += Math.sin(phase) * pa[3];
		m2 += Math.cos(phase) * pa[3];
	    }

	    var r = (m1 + 1) * 127;
	    var g = (m2 + 1) * 127;
	    var b = (2 - Math.sqrt(r * r + g * g)) * 127;

	    pixels[offset ++] = Math.round(r);
	    pixels[offset ++] = Math.round(g);
	    pixels[offset ++] = Math.round(b);
	    pixels[offset ++] = 0xff;
	}
    }

    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
}

function effectInit(gl, shader) {
    var texturesToLoad = 1;
    var textureWater;
    var textureNoise = makeNoiseTexture(gl);
    var textureWater = makeWaterTexture(gl);

    /* Bind the noise texture to texture unit 0. */
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textureNoise);
    gl.uniform1i(gl.getUniformLocation(shader, "uNoise"), 0);

    /* Bind the water map to texture unit 1.
     * If this doesn't work for some reason, we only
     * lose water waves... */
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textureWater);
    gl.uniform1i(gl.getUniformLocation(shader, "uWatermap"), 1);

    effectStart(gl, shader);
}
</script>
</head>
<body>

<canvas id="canvas" width="512" height="512"></canvas>

</body>
</html>
