<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><title>Landscape rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Water texture */
uniform sampler2D uWatermap;
/* Noise texture */
uniform sampler2D uNoise;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

/* How far to subdivide modified Perlin noise.
 * (Determines how coarse the terrain is.) */
const int MAPITERATIONS = 6;
/* How many march iterations per ray. */
const int RAYITERATIONS = 256;
/* Convert distance between ray and terrain position to "safe" advancing step. */
const float MARCH_SPEED = 0.5;
/* Level Of Detail: how far to render until dropping terrain features. */
const float LOD = 2.0;
/* When ray reaches close enough to terrain, stop marching */
const float STOPCONDITION = 0.0025;
/* Render distance. */
const float FOG = 5.;
/* Water level */
const float WATER_LEVEL = 0.79;
/* Water surface precision */
const int WATER_BISECTIONS = 4;
/* Direction to infinitely far-away Sun */
const vec3 SUN = vec3(0.9, 0., 0.45);
/* Sun's brightness. */
const float SUN_INTENSITY = 8.;
/* The camera up direction. */
const vec3 UP = vec3(0., 0., 1.);

const vec2 F2 = vec2(0.366025403784, 0.366025403784);
const vec2 G2 = vec2(0.211324865405, 0.211324865405);
const float ONE = 1./256.;

/* This function is based on the work of John Davis and Stefan Gustavson. */
vec3 simplex2d(in vec2 P) {
    vec2 Pi = floor(P + dot(P, F2));
    vec2 Pf0 = P - Pi + dot(Pi, G2);

    // For the 2D case, the simplex shape is an equilateral triangle.
    // Find out whether we are above or below the x=y diagonal to
    // determine which of the two triangles we're in.
    vec2 o1 = vec2(Pf0.x > Pf0.y, Pf0.x <= Pf0.y);

    /* Get simplex gradients. The texture
     * contains 4 values per pixel, the rg pair being
     * gradient at (0, 0) and ba pair being the gradient at (1, 1).
     */
    Pi += .5;
    vec4 grad02 = texture2D(uNoise, Pi * ONE) * 2.0 - 1.0;
    vec2 grad0 = grad02.rg;
    vec2 grad1 = texture2D(uNoise, (Pi + o1) * ONE).rg * 2.0 - 1.0;
    vec2 grad2 = grad02.ba;

    vec2 Pf1 = Pf0 - o1 + G2;
    vec2 Pf2 = Pf0 + 2.0 * G2 - 1.0;
    vec3 t = max(0.5 - vec3(dot(Pf0, Pf0), dot(Pf1, Pf1), dot(Pf2, Pf2)), 0.);
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;

    vec3 td = t * t2 * vec3(dot(grad0, Pf0), dot(grad1, Pf1), dot(grad2, Pf2));
    float dx = 8. * dot(td, vec3(Pf0.x, Pf1.x, Pf2.x)) - dot(t4, vec3(grad0.x, grad1.x, grad2.x));
    float dy = 8. * dot(td, vec3(Pf0.y, Pf1.y, Pf2.y)) - dot(t4, vec3(grad0.y, grad1.y, grad2.y));

    // Sum up and scale the result to cover the range [-.5,.5]
    return vec3(dot(td, t), dx, dy) * 70.;
}

/* Combine simplex noise to given octave.
 * Output: vec4(normalx, normaly, normalz, value) */
vec4 fbmPerlin2d(in vec2 pos, in int maxLevel) {
    pos *= .25;
    float w = 0.5;
    vec3 o = vec3(w, 0., 0);
    for (int i = 0; i < 8; i ++) {
        o += w * simplex2d(pos);
        if (i >= maxLevel) {
            break;
        }
        w *= .5;
        pos *= 2.;
    }
    
    return vec4(normalize(cross(vec3(-1., 0., o.y), vec3(0., -1., o.z))), o.x);
}

/* Combine simplex noise to given octave with enhancement by Inigo Quilez.
 * Output: value. */
float fbmQuilez2d(in vec2 pos, in int lastIteration) {
    pos *= .25;
    float w = 0.5;
    float o = w;
    vec2 d = vec2(0., 0.);
    for (int i = 0; i < MAPITERATIONS; i ++) {
        vec3 n = simplex2d(pos);
	d += n.yz * .5;
        o += n.x * (w / (1. + dot(d, d)));
	if (i == lastIteration) {
	    break;
	}
        w *= .5;
        pos *= 2.;
    }

    return o * 2.;
}

/* Combine simplex noise to given octave with enhancement by Inigo Quilez.
 * Output: normal. */
vec3 fbmQuilez2dNormal(in vec2 pos, in int lastIteration) {
    pos *= .25;
    float w = 0.5;
    vec2 o = vec2(0., 0.);
    vec2 d = vec2(0., 0.);
    for (int i = 0; i < MAPITERATIONS; i ++) {
        vec3 n = simplex2d(pos);
	d += n.yz * .5;
	o += n.yz * (w / (1. + dot(d, d)));
	if (i == lastIteration) {
	    break;
	}
        w *= .5;
        pos *= 2.;
    }

    o *= 2.;
    return normalize(cross(vec3(-1., 0., o.x), vec3(0., -1., o.y)));
}

vec4 getWaterTexture(in vec3 pos) {
    vec4 wave1 = texture2D(uWatermap, pos.xy * 1.7 + vec2(uTime *.07, 0.));
    vec4 wave2 = texture2D(uWatermap, pos.xy + vec2(0., uTime *.11));
    return wave1 - wave2;
}

/* Get water normal */
vec3 getWaterNormal(in vec3 pos) {
    vec2 waves = getWaterTexture(pos).xy;
    return vec3(waves, 1.0 - sqrt(dot(waves, waves)));
}

/* Get water level */
float getWaterLevel(in vec3 pos) {
    float ripple = getWaterTexture(pos).z;
    return WATER_LEVEL - ripple * .1;
}

/* Terrain marching.
 *
 * At each step along the way, the height of the ray from
 * ground is computed, and this is converted into a guesstimate
 * about a "safe" distance for ray to skip forwards.
 *
 * The octaves of Perlin noise that generates the landscape are
 * reduced if the ray appears to be far from the terrain, or
 * far from viewer.
 *
 * The stop condition also gets progressively coarser as
 * the ray gains distance to viewer. This should naturally "antialias"
 * the scenery at distance.
 *
 * Output: LOD value for terrain calculation.
 */
float intersectTerrain(inout vec3 pos, in vec3 dir) {
    /* Dynamic LOD during marching:
     * After distance to scene has been acquired, update LOD. */
    float t = 0.0;
    for (int i = 0; i < RAYITERATIONS; i ++) {
        float height = pos.z - fbmQuilez2d(pos.xy, MAPITERATIONS);
	
	/* There's a trick here. Our distance estimates are not conservative;
	 * if the ray steps into the terrain, height is negative, and the ray will
         * backtrack automatically. */
        float distanceEstimate = height * MARCH_SPEED;
        t += distanceEstimate;
        pos += distanceEstimate * dir;

        if (t > FOG) {
	    t = FOG;
	    break;
        }

        /* Are we close enough to terrain? */
	float absHeight = abs(height);
        if (absHeight < STOPCONDITION * t) {
	    break;
        }

	float waterLevel = getWaterLevel(pos);
	if (pos.z < waterLevel) {
	    /* underwater; find intersection point. */

	    /* Initial brackets: earlier iteration was above,
	     * this one is below. Therefore, there must be an
	     * intersection point. */
	    float b = t;
	    float a = t - distanceEstimate;

	    for (int i = 0; i < WATER_BISECTIONS; i ++) {
		/* Estimate distance to water. */
		float underwaterLength = (waterLevel - pos.z) / dir.z;
		float t2 = t + underwaterLength;

		/* Is the new root outside the established brackets? */
		if (t2 < a || t2 > b) {
		    /* Try again at range midpoint. */
		    waterLevel = getWaterLevel(pos);
		    t2 = (a + b) * .5;
		}

		pos += dir * (t2 - t);
		t = t2;
		waterLevel = getWaterLevel(pos);
		
		/* Discover root brackets as we go. */
		if (waterLevel < pos.z) {
		    a = t;
		} else {
		    b = t;
		}

	    }
	    pos.z = waterLevel;
	    break;
	}

    }

    return t;
}

/* Evaluate rules to find color of terrain point.
 * Output: RGB. */
vec3 getTerrainColor(in vec3 pos, in vec3 dir) {
    /* Get surface properties. */
    vec3 normal = fbmQuilez2dNormal(pos.xy, MAPITERATIONS);
    vec4 noise = fbmPerlin2d(pos.xy * 64., 4);
    float grassNoise = fbmQuilez2d(pos.xy * 256., 1);
    vec4 highfreqNoise = fbmPerlin2d(pos.xy * 1024., 3);

    /* Sand */
    vec4 terrain = vec4(1., 1., .5, 0.) * (.5 + .5 * highfreqNoise.w) * pos.z;
    vec3 terrainNormal = vec3(0., 0., 0.);

    /* Grass -- if terrain is not flat, the beach is shorter */
    float beachOrGrass = smoothstep(.75, .76, pos.z - normal.z * .1);
    vec4 grass = vec4(0.1, 0.2, 0.00, 0.) * grassNoise;
    terrain = mix(terrain, grass, beachOrGrass);

    /* Rock: two layers of texturing and normals:
     * first layer is coarse world-terrain noise
     * added to it is the same high-frequency noise
     * used for sand and grass */
    float greenOrBarren = smoothstep(.5, .6, pos.z - normal.z + noise.w * .2);
    float rockStripe = (noise.w - 0.3) * 1.5;
    rockStripe = rockStripe * rockStripe;
    vec4 rock = vec4(.3, .3, .3, .1) + highfreqNoise.w * highfreqNoise.w * highfreqNoise.w;
    terrain = mix(terrain, rock * rockStripe, greenOrBarren);
    vec3 rockNormal = noise.xyz + highfreqNoise.xyz;
    terrainNormal = mix(terrainNormal, rockNormal, greenOrBarren);

    /* Snow -- height increased if terrain is not flat. */
    float barrenOrSnow = smoothstep(2.5, 2.6, pos.z + normal.z + noise.w * .2);
    terrain = mix(terrain, vec4(1.4, 1.4, 1.4, .1), barrenOrSnow);
    terrainNormal = mix(terrainNormal, vec3(0., 0., 0.), barrenOrSnow);
   
    /* Apply lighting */
    normal = normalize(normal + terrainNormal * .4);
    float diffuse = max(dot(normal, SUN), 0.2);
    vec3 reflection = 2. * normal * dot(SUN, normal) - SUN;

    return (terrain.xyz * diffuse + SUN_INTENSITY * terrain.w * pow(max(-dot(reflection, dir), 0.), 20.));

}

/* Render sky.
 * Output: RGB.
 */
vec3 getSkyColor(in vec3 pos, in vec3 dir) {
    float sunAngle = max(dot(dir, SUN), 0.);
    float sunSpecular = pow(sunAngle, 40.);
    float skyBrightness = clamp(1. - dir.z, 0., 1.);
    float clouds = fbmPerlin2d(pos.xy + dir.xy * (8. - pos.z) / dir.z, 3).w;
    clouds *= clouds;
    return mix(vec3(skyBrightness, skyBrightness, 1.) * .8, vec3(1., 1., 1.), clouds * dir.z) * (1. + sunAngle)
	+ SUN_INTENSITY * sunSpecular;
}

/* Add distance fog to color.
 * Output: RGB.
 */
vec3 applyFog(in vec3 color, in float distance) {
    distance /= FOG;
    return mix(color, vec3(.8, .8, .8), distance*distance);
}

/* Calculate water color based on reflection and refraction.
 * Output: RGB.
 */
vec3 getWaterColor(in vec3 pos, in vec3 dir) {
    vec3 normal = getWaterNormal(pos);

    /* Fresnel equation approximation */
    float reflectionOrRefraction = max(-dot(dir, normal), 0.);
    reflectionOrRefraction = sqrt(reflectionOrRefraction);
    vec3 reflection = dir - 2. * normal * dot(dir, normal);

    /* Reflect scenery */
    vec3 reflectionPos = pos;
    float reflectionLength = intersectTerrain(reflectionPos, reflection);
    vec3 reflectedTerrain = getTerrainColor(reflectionPos, reflection);

    /* Add sky */
    if (reflectionLength / FOG == 1.) {
	reflectedTerrain = getSkyColor(reflectionPos, reflection);
    } else {
	reflectedTerrain = applyFog(reflectedTerrain, reflectionLength);
    }

    /* Refract scenery (utterly fake). */
    float waterDepth = getWaterLevel(pos) - fbmQuilez2d(pos.xy, MAPITERATIONS);
    pos.xy += (dir.xy + normal.xy) * .5 * waterDepth;
    pos.z = fbmQuilez2d(pos.xy, MAPITERATIONS);
    vec3 refractedTerrain = getTerrainColor(pos, normal);
    /* caustics */
    refractedTerrain *= 1. + waterDepth * pow(.95 + normal.x - normal.y, 20.);

    return mix(reflectedTerrain, refractedTerrain, reflectionOrRefraction);
}
    
/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

void main(void) {
    //gl_FragColor = texture2D(uWatermap, vPosition);
    //gl_FragColor = vec4(fbmPerlin2d(vPosition*4., 0) * vec3(1., 1., 1.), 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmPerlin2dNormal(vPosition*4., 0), 1.);
    //gl_FragColor = vec4(fbmQuilez2d(vPosition * 8., 8) * vec3(1., 1., 1.) * .5);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmQuilez2dNormal(vPosition * 8., 8) * .5);
    //return;

    /* Calculate position of camera. */
    float groundHeight = fbmQuilez2d(uPos.xy, 2);
    if (groundHeight < WATER_LEVEL) {
	groundHeight = WATER_LEVEL;
    }
    vec3 cameraPos = vec3(uPos.xy, groundHeight + pow(2., -2.));
    
    /* Calculate an orthonormal basis based on lookat and up vector. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);
    
    /* Terrain march. */
    vec3 terrainPos = cameraPos;
    float distance = intersectTerrain(terrainPos, dir);
    float waterLevel = getWaterLevel(terrainPos);

    /* Blend water if under water level. */
    vec3 terrain;
    if (terrainPos.z == waterLevel) {
	terrain = getWaterColor(terrainPos, dir);
    } else {
	terrain = getTerrainColor(terrainPos, dir);

	/* add shadow: use sampling in an attempt of trying to find out the
	 * maximum amount the ray from terrain point to sun is goes under terrain. */
	float shadow = 0.0;
	vec3 pos = terrainPos + texture2D(uNoise, vPosition).r * SUN * .1;
	for (int i = 0; i < 8; i ++) {
	    float rayHeight = fbmQuilez2d(pos.xy, 3) - terrainPos.z;
	    pos += SUN * max(0.1, rayHeight);
	    shadow = max(shadow, rayHeight);
	}
	terrain *= smoothstep(0.4, 0.0, shadow);
    }

    /* Distance fog. */
    terrain = applyFog(terrain, distance);

    /* Sky */
    if (distance / FOG == 1.) {
	terrain = getSkyColor(cameraPos, dir);
    }

    float exposureControl = 1. - max(dot(uDir, SUN), 0.) * (1. - 1./SUN_INTENSITY);
    gl_FragColor = vec4(sqrt(terrain * exposureControl), 1);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">

function prng(n) {
    n = (n ^ (n << 13)) & 0xffff;
    n = n * n;
    n ^= n << 5;
    return n ^ (n >> 7) & 0xffff;
}

function makeNoiseTexture(gl) {
    var pixels = new Uint8Array(256 * 256 * 4);
    var offset = 0;
    for (var i = 0; i < 256; i++) {
	for (var j = 0; j < 256; j++) {
	    var v1 = prng(j + prng(i) & 0xff);
	    var v2 = prng(j + 1 + prng(i + 1) & 0xff);
	    pixels[offset ++] = v1 & 0xff;
	    pixels[offset ++] = v1 >> 8;
	    pixels[offset ++] = v2 & 0xff;
	    pixels[offset ++] = v2 >> 8;
	}
    }
    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    return texture;
}

function makeWaterTexture(gl) {
    var waveParams = [];
    for (var wave = 0; wave < 20; wave ++) {
	var wp = prng(1234 ^ wave);
	waveParams.push([wp & 0xf, (wp >> 4) & 0xf, (wp >> 8) & 0xf, (1 + (wp >> 12) & 0xf) / 16 / 30]);
    }

    var pixels = new Uint8Array(512 * 512 * 4);
    var offset = 0;
    for (var i = 0; i < 512; i++) {
	var ifact = 2 * Math.PI * i / 512;
	for (var j = 0; j < 512; j++) {
	    var jfact = 2 * Math.PI * j / 512;

	    var dx = 0;
	    var dy = 0;
	    var z = 0;
	    for (var wave = 0; wave < waveParams.length; wave ++) {
		var pa = waveParams[wave];
		var phase = ifact * pa[0] + jfact * pa[1] + pa[2];
		dx += Math.sin(phase) * pa[3];
		dy += Math.cos(phase) * pa[3];
	    }

	    var z = dx - dy;
	    pixels[offset ++] = Math.round((dx + 1) * 127);
	    pixels[offset ++] = Math.round((dy + 1) * 127);
	    pixels[offset ++] = Math.round(( z + 1) * 127);
	    pixels[offset ++] = 0xff;
	}
    }

    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
}

function effectInit(gl, shader) {
    var texturesToLoad = 1;
    var textureWater;
    var textureNoise = makeNoiseTexture(gl);
    var textureWater = makeWaterTexture(gl);

    /* Bind the noise texture to texture unit 0. */
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textureNoise);
    gl.uniform1i(gl.getUniformLocation(shader, "uNoise"), 0);

    /* Bind the water map to texture unit 1.
     * If this doesn't work for some reason, we only
     * lose water waves... */
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textureWater);
    gl.uniform1i(gl.getUniformLocation(shader, "uWatermap"), 1);

    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Would Iñigo Quilez like it here?</h1>
<div>
<canvas id="canvas" width="512" height="512"></canvas>
</div>

<p>Shown here is a 3D world rendered in fragment shader. There is no
triangle geometry of any kind. The world is rendered instead by a terrain
marching technique, where a distance field is iterated until a point in
world's surface has been reached.</p>

<p>The terrain is calculated by the shader from simplex noise and fractional
brownian motion similar to the formulation proposed by Quilez. This marching
doesn't use many octaves of noise for performance reasons; to liven the result
up, various procedural textures are calculated and applied to the scenery based
on height, fbm noise and surface tilt.  </p>

<p>The water surface is a sum of about 40 2D sin waves, rendered with aid of
a bumpmap calculated in JavaScript during effect's init. Note that the
surface is real in sense that it actually has a height. The water is
entirely colorless liquid, and its color is built from combination of
reflection, refraction and caustics.
</p>


</body>
</html>
