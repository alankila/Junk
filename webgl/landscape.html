<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><title>Landscape rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Water texture */
uniform sampler2D uWatermap;
/* Noise texture */
uniform sampler2D uNoise;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

/* How many march iterations per ray. */
const int RAYITERATIONS = 256;
/* Convert distance between ray and terrain position to "safe" advancing step. */
const float MARCH_SPEED = 0.5;
/* Level Of Detail: how far to render until dropping terrain features. */
const float LOD = 2.0;
/* When ray reaches close enough to terrain, stop marching */
const float STOPCONDITION = 0.0025;
/* Render distance. */
const float FOG = 5.;
/* Water level */
const float WATER_LEVEL = 0.4;
/* Water surface precision */
const int WATER_BISECTIONS = 4;
/* The camera up direction. */
const vec3 UP = vec3(0., 0., 1.);
/* Sun brightness */
const float SUN_INTENSITY = 8.;

/* Get vector towards Sun.
 * Output: normalized vector.
 */
vec4 getSun() {
    float sunPhase = uTime * .01;
    float z = cos(sunPhase) * 0.7071;
    return vec4(sin(sunPhase) * 0.7071, 0.7071, z, max(SUN_INTENSITY * z + 0.1, 0.05));
}

/* Return gradient noise value, derivates, and ambient occlusion if used for heightmap.
 * output: vec4(z, dx, dy, ao)
 */
vec4 noise2d(in vec2 point) {
    return (texture2D(uNoise, point) - vec4(.5, .5, .5, 0.)) * vec4(1., 2., 2., 1.);
}

/* Combine simplex noise to given octave.
 * Output: vec3(dx, dy, value, ao)
 */
vec4 fbmPerlin2d(in vec2 pos, in int lastIteration) {
    float w = 0.5;
    vec4 o = vec4(w, 0., 0, 0.);
    for (int i = 0; i < 16; i ++) {
        o += w * noise2d(pos);
        if (i == lastIteration) {
            break;
        }
        w *= .5;
        pos *= 2.;
    }
    return o;
}

/* Combine simplex noise to given octave with enhancement by Inigo Quilez.
 * Output: vec3(normalx, normaly, normalz, value) */
vec4 fbmQuilez2d(in vec2 pos, in float spikiness, in int lastIteration) {
    float w = 0.5;
    vec4 o = vec4(w, 0., 0., 0.);
    vec2 d = vec2(0., 0.);
    for (int i = 0; i < 16; i ++) {
        vec4 n = noise2d(pos);
	d += n.yz * spikiness;
	float wf = w / (1. + dot(d, d));
        o += wf * n;
	if (i == lastIteration) {
	    break;
	}
        w *= .5;
        pos *= 2.;
    }
    return o;
}

vec4 getNoise(in vec2 pos, in int lastIteration) {
    vec3 o = fbmPerlin2d(pos, lastIteration).xyz;
    return vec4(normalize(cross(vec3(-1., 0., o.y), vec3(0., -1., o.z))), o.x);
}

vec4 getTerrain(in vec2 pos) {
    vec3 o = fbmQuilez2d(pos * (1./512.), 0.5, 4).xyz * 2.;
    return vec4(normalize(cross(vec3(-1., 0., o.y), vec3(0., -1., o.z))), o.x);
}

float getTerrainAo(in vec2 pos) {
    return fbmQuilez2d(pos * (1./512.), 0.5, 4).w;
}

vec4 getWaterTexture(in vec3 pos) {
    vec4 wave1 = texture2D(uWatermap, pos.xy * 1.7 + vec2(uTime *.07, 0.));
    vec4 wave2 = texture2D(uWatermap, pos.xy + vec2(0., uTime *.11));
    return (wave1 - wave2) * .5;
}

/* Get water normal */
vec3 getWaterNormal(in vec3 pos) {
    vec2 waves = getWaterTexture(pos).xy;
    return vec3(waves, 1.0 - sqrt(dot(waves, waves)));
}

/* Get water level */
float getWaterLevel(in vec3 pos) {
    float ripple = getWaterTexture(pos).z;
    return WATER_LEVEL - ripple * .1;
}

/* Terrain marching.
 *
 * At each step along the way, the height of the ray from
 * ground is computed, and this is converted into a guesstimate
 * about a "safe" distance for ray to skip forwards.
 *
 * The octaves of Perlin noise that generates the landscape are
 * reduced if the ray appears to be far from the terrain, or
 * far from viewer.
 *
 * The stop condition also gets progressively coarser as
 * the ray gains distance to viewer. This should naturally "antialias"
 * the scenery at distance.
 *
 * Output: LOD value for terrain calculation.
 */
float intersectTerrain(inout vec3 pos, in vec3 dir) {
    /* Dynamic LOD during marching:
     * After distance to scene has been acquired, update LOD. */
    float t = 0.0;
    for (int i = 0; i < RAYITERATIONS; i ++) {
        float height = pos.z - getTerrain(pos.xy).w;
	
	/* There's a trick here. Our distance estimates are not conservative;
	 * if the ray steps into the terrain, height is negative, and the ray will
         * backtrack automatically. */
        float distanceEstimate = height * MARCH_SPEED;
        t += distanceEstimate;
        pos += distanceEstimate * dir;

        if (t > FOG) {
	    t = FOG;
	    break;
        }

	float waterLevel = getWaterLevel(pos);
	if (pos.z < waterLevel) {
	    /* underwater; find intersection point. */

	    /* Initial brackets: earlier iteration was above,
	     * this one is below. Therefore, there must be an
	     * intersection point. */
	    float b = t;
	    float a = t - distanceEstimate;

	    for (int i = 0; i < WATER_BISECTIONS; i ++) {
		/* Estimate distance to water. */
		float underwaterLength = (waterLevel - pos.z) / dir.z;
		float t2 = t + underwaterLength;

		/* Is the new root outside the established brackets? */
		if (t2 < a || t2 > b) {
		    /* Try again at range midpoint. */
		    waterLevel = getWaterLevel(pos);
		    t2 = (a + b) * .5;
		}

		pos += dir * (t2 - t);
		t = t2;
		waterLevel = getWaterLevel(pos);
		
		/* Discover root brackets as we go. */
		if (waterLevel < pos.z) {
		    a = t;
		} else {
		    b = t;
		}

	    }
	    
	    pos.z = waterLevel;
	    break;
	}

        /* Are we close enough to terrain? */
	float absHeight = abs(height);
        if (absHeight < STOPCONDITION * t) {
	    pos.z = getTerrain(pos.xy).w;
	    break;
        }

    }

    return t;
}

/* Minimal raymarcher that attempts to discover a point's shading.
 * Output: lighting factor
 */
float calculateShade(in vec3 pos) {
    /* add shadow: use sampling in an attempt of trying to find out the
     * maximum amount the ray from terrain point to sun is goes under terrain. */
    float shadow = 0.;
    float t = 0.01;

    vec3 sun = getSun().xyz;
    vec3 testpos = pos;
    for (int i = 0; i < 5; i ++) {
	testpos += sun * t;
	/* Positive -> above ground. */
	float rayHeight = testpos.z - getTerrain(testpos.xy).w;
	float inShadow = rayHeight;
	shadow += min(inShadow, 0.);
	if (inShadow < -0.01) {
	    break;
	}
	t *= 1.4;
    }

    return clamp(100. * shadow + 1., 0., 1.);
}

/* Evaluate rules to find color of terrain point.
 * Output: RGB. */
vec3 getTerrainColor(in vec3 pos, in vec3 dir) {
    /* Get surface properties. */
    vec3 normal = getTerrain(pos.xy).xyz;
    float ao = getTerrainAo(pos.xy);
    vec4 noise = fbmQuilez2d(pos.xy / 32., 2.0, 8) * 1.;
    noise = vec4(normalize(cross(vec3(-1., 0., noise.y), vec3(0., -1., noise.z))), noise.x);

    /* Tilt the coarse surface with detail texture. */
    normal = normalize(normal + noise.xyz);
    
    /* Determine terrain type. */
    float overWater = smoothstep(WATER_LEVEL, WATER_LEVEL + 0.1, pos.z);
    float sandOrRock = smoothstep(0.90, 0.85, normal.z - pos.z * .25 - overWater);
    //float foliage = sandOrRock * smoothstep(0.96, 0.97, normal.z);
    float rockOrSnow = smoothstep(1.04, 1.05, normal.z + pos.z * .1) * overWater;

    /* Sand texture */
    vec4 terrain = vec4(0.2, 0.2, 0.14, 0.) * pos.z;

    /* Rock texture */
    vec4 rockNoise = getNoise(pos.xy * 4., 1);
    vec4 rockTexture = vec4(.05, .04, .025, 0.) * noise.w;
    rockTexture += vec4(.03, .015, .008, 0.03) * rockNoise.w * rockNoise.w;
    terrain = mix(terrain, rockTexture, sandOrRock);
    normal = normalize(mix(normal, rockNoise.xyz,  sandOrRock * (1. - rockOrSnow) * .1));

    /* Foliage: if not under water, or above snow line, and terrain tilt is suitable. */
    //vec4 grass = vec4(0.01, 0.02, 0.00, 0.);
    //terrain = mix(terrain, grass, foliage);

    /* Snow -- height increased if terrain is not flat. */
    terrain = mix(terrain, vec4(.21, .21, .21, .21), rockOrSnow);
   
    /* Apply lighting */
    normal = normalize(normal);
    vec4 sun = getSun();
    vec3 reflection = reflect(sun.xyz, normal);
    float diffuse = max(dot(normal, sun.xyz), 0.0);
    float specular = max(dot(reflection, dir), 0.);
    float shade = calculateShade(pos);

    /* Modified Phong shading. The ambient level is fixed at .1.
     * The shadow masks out diffuse and the specular component. */
    return terrain.xyz * (.1 * ao + diffuse * shade)
	 + shade * terrain.w * pow(specular, 20.);
}

float getCloudOpacity(vec2 spos, vec3 dir, out float darkness) {
    float opacity = 0.;
    vec3 pos = vec3(spos, 0.);
    darkness = 1. - getNoise(pos.xy * (1./128.) + 1., 4).w * .5;
    for (int j = 0; j < 10; j ++) {
	float o = getNoise((pos.xy + vec2(uTime*.04, 1.)) / 128., 4).w;

	/* is there cloud above the ray? */
	float dz = o - pos.z - 0.5;
	float step = max(0.03, abs(dz) * MARCH_SPEED);
	opacity += max(dz, 0.);

	pos += dir * step;
	if (pos.z > 1.) {
	    break;
	}
    }

    return opacity;
}

/* Render sky.
 * Output: RGB.
 */
vec3 getSkyColor(in vec3 pos, in vec3 dir) {
    vec4 sun = getSun();
    float sunAngle = max(dot(dir, sun.xyz), 0.);
    float sunDisc = pow(sunAngle, 40.);
    float skyBrightness = clamp(1. - dir.z, 0., 1.);

    vec3 skyColor = (vec3(skyBrightness, skyBrightness, 1.) * .1 + sunDisc);
    float starNoise = getNoise(vec2(acos(dir.z), atan(dir.x, dir.y)) * .5, 1).w;
    skyColor += vec3(.05, .05, .05) / sun.w * smoothstep(0.75, 0.85, starNoise);

    float cloudTotal = 0.;
    float t = (2.5 - pos.z) / dir.z;

    vec2 cloudCoord = pos.xy + dir.xy * t;
    float darkness;
    float cloudOpacity = getCloudOpacity(cloudCoord, dir, darkness);
    t /= FOG;
    cloudOpacity /= (1. + t * t);
    return mix(skyColor, vec3(.3, .3, .3) * darkness, cloudOpacity);
}

/* Add fog to color.
 * The real fog would be an exponential process as function of
 * distance, but we are just simulating it with 1/(distance*distance) style
 * mixing of some grayish shade.
 *
 * Output: RGB.
 */
vec3 applyFog(in vec3 color, in float distance) {
    distance /= FOG;
    return mix(color, vec3(.1, .1, .1), distance*distance);
}

/* Calculate water color based on reflection and refraction.
 * Output: RGB.
 */
vec3 getWaterColor(in vec3 pos, in vec3 dir) {
    vec3 normal = getWaterNormal(pos);

    /* Fresnel equation approximation */
    float reflectionOrRefraction = max(-dot(dir, normal), 0.);
    reflectionOrRefraction = sqrt(reflectionOrRefraction);

    /* Reflect scenery */
    vec3 reflectionPos = pos;
    vec3 reflection = reflect(dir, normal);
    float reflectionLength = intersectTerrain(reflectionPos, reflection);
    vec3 reflectedTerrain = getTerrainColor(reflectionPos, reflection);

    /* Add sky */
    if (reflectionLength / FOG == 1.) {
	reflectedTerrain = getSkyColor(pos, reflection);
    } else {
	reflectedTerrain = applyFog(reflectedTerrain, reflectionLength);
    }

    /* Refract scenery (utterly fake). */
    float waterDepth = getWaterLevel(pos) - getTerrain(pos.xy).w;
    pos.xy += refract(dir, normal, 0.7).xy * waterDepth;
    pos.z = getTerrain(pos.xy).w;
    vec3 refractedTerrain = getTerrainColor(pos, normal);
    /* Caustics */
    refractedTerrain *= 1. + waterDepth * pow(1.0 + normal.x - normal.y, 20.);

    return mix(reflectedTerrain, refractedTerrain, reflectionOrRefraction);
}
    
/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

vec3 cameraExposure(vec3 terrain, vec3 dir) {
    vec4 sun = getSun();
    /* We want Sun to always be 2x exposed.
     * 
     * We don't know much about the world geometry here, but we know that
     * the Sun shines at the brightness level sun.w. If the user views too
     * close to the Sun, we progressively diminish the sun's brightness
     * term until it is no more than 2 at directly looking at Sun.
     * If sun, however, is dimmer than 2, then we just use whatever value it
     * gives.
     */
    float exposureControl = mix(sun.w, min(sun.w, 2.), max(dot(sun.xyz, dir), 0.));

    /* As sun goes down, turn shades towards red.
     * Lowest brightness adjustment is (1.0, 0.5, 0.5). */
    vec3 sunColor = vec3(
	1.0,
	1.0 + clamp(sun.z - 0.3, -0.8, 0.0),
	1.0 + clamp(sun.z - 0.4, -0.9, 0.0)
    );

    /* sqrt here is gamma correction! */
    return sqrt(terrain * sunColor * exposureControl);
}

void main(void) {
    //gl_FragColor = vec4(texture2D(uNoise, vPosition * .5 * .25).www, 1.);
    //gl_FragColor = texture2D(uWatermap, vPosition);
    //gl_FragColor = vec4(fbmPerlin2d(vPosition * .5, 8).w * vec3(.1, 1., 1.), 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmPerlin2d(vPosition*4., 8).xyz, 1.);
    //gl_FragColor = vec4(fbmQuilez2d(vPosition, 1., 8).w * vec3(1., 1., 1.) * .5, 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmQuilez2d(vPosition, 1., 8).xyz * .5, 1.);
    //return;

    /* Calculate position of camera. */
    float groundHeight = getTerrain(uPos.xy).w;
    if (groundHeight < WATER_LEVEL) {
	groundHeight = WATER_LEVEL;
    }
    vec3 cameraPos = vec3(uPos.xy, groundHeight + pow(2., -4.));
    
    /* Calculate an orthonormal basis based on lookat and up vector. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);
    
    /* Terrain march. */
    vec3 terrainPos = cameraPos;
    float distance = intersectTerrain(terrainPos, dir);
    float waterLevel = getWaterLevel(terrainPos);

    /* Blend water if under water level. */
    vec3 terrain;
    if (terrainPos.z == waterLevel) {
	terrain = getWaterColor(terrainPos, dir);
    } else {
	terrain = getTerrainColor(terrainPos, dir);
    }

    if (distance / FOG == 1.) {
	terrain = getSkyColor(cameraPos, dir);
    } else {
	terrain = applyFog(terrain, distance);
    }

    gl_FragColor = vec4(cameraExposure(terrain, uDir), 1.);
}

</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">

function prng(n) {
    var m = n;
    for (var i = 0; i < 3; i ++) {
	n = (n & 0xffff) + m & 0xffff;
	m = m + n & 0xffff;
	n += n * n;
	n ^= n >> 15;
    }

    return n & 0xffff;
}

function makeNoiseTexture(gl) {
    var perm = [];
    for (var i = 0; i < 256; i ++) {
	perm.push(prng(i + 12213));
    }
    var getValueNoise = function(i, j) {
	return perm[i + perm[j & 0xff] & 0xff] & 0xff;
    };

    var pixels = new Uint8Array(1024 * 1024 * 4);
    var offset = 0;
    for (var ix = 0; ix < 1024; ix++) {
	var i = ix >> 2;
	var u = ((ix & 3) + (1/2)) / 4;
	var du = 30 * u * u * (u * (u - 2) + 1);
	u = u * u * u * (u * (u * 6 - 15) + 10);

	for (var jx = 0; jx < 1024; jx++) {
	    var j = jx >> 2;
	    var v = ((jx & 3) + (1/2)) / 4;

	    /* quintic fade */
	    var dv = 30 * v * v * (v * (v - 2) + 1);
	    v = v * v * v * (v * (v * 6 - 15) + 10);

	    var v0 = getValueNoise(i, j);
	    var v1 = getValueNoise(i+1, j);
	    var v2 = getValueNoise(i, j+1);
	    var v3 = getValueNoise(i+1, j+1);

	    var ku = v1 - v0;
	    var kv = v2 - v0;
	    var kuv = v0 + v3 - v1 - v2;

	    var dx = -du * (ku + kuv*v);
	    var dy = -dv * (kv + kuv*u);

	    pixels[offset ++] = Math.round(v0 + ku*u + kv*v + kuv*u*v);
	    pixels[offset ++] = Math.round((dx + .5) * 0x7f);
	    pixels[offset ++] = Math.round((dy + .5) * 0x7f);
	    pixels[offset ++] = 0;
	}
    }

    /* Post-process ambient occlusion term. */
    var offset = 0;
    for (var ix = 0; ix < 1024; ix++) {
	for (var jx = 0; jx < 1024; jx++) {
	    var v = pixels[ix * (1024 * 4) + jx * 4];
	    var vu = pixels[(ix - 1 & 0x3ff) * (1024 * 4) + jx * 4];
	    var vd = pixels[(ix + 1 & 0x3ff) * (1024 * 4) + jx * 4];
	    var vl = pixels[ix * (1024 * 4) + (jx - 1 & 0x3ff) * 4];
	    var vr = pixels[ix * (1024 * 4) + (jx + 1 & 0x3ff) * 4];

	    var ao = 256 - (4 * v - vu - vd - vl - vr);
	    if (ao < 0) {
		ao = 0;
	    }
	    if (ao > 255) {
		ao = 255;
	    }

	    pixels[ix * (1024 * 4) + jx * 4 + 3] = ao;
	}
    }

    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    return texture;
}

function makeWaterTexture(gl) {
    var waveParams = [];
    for (var wave = 0; wave < 20; wave ++) {
	var wp = prng(wave);
	waveParams.push([wp & 0xf, (wp >> 4) & 0xf, (wp >> 8) & 0xf, (1 + (wp >> 12) & 0xf) / 16 / 30]);
    }

    var pixels = new Uint8Array(512 * 512 * 4);
    var offset = 0;
    for (var i = 0; i < 512; i++) {
	var ifact = 2 * Math.PI * i / 512;
	for (var j = 0; j < 512; j++) {
	    var jfact = 2 * Math.PI * j / 512;

	    var dx = 0;
	    var dy = 0;
	    var z = 0;
	    for (var wave = 0; wave < waveParams.length; wave ++) {
		var pa = waveParams[wave];
		var phase = ifact * pa[0] + jfact * pa[1] + pa[2];
		dx += Math.sin(phase) * pa[3];
		dy += Math.cos(phase) * pa[3];
	    }

	    var z = dx - dy;
	    pixels[offset ++] = Math.round((dx + 1) * 127);
	    pixels[offset ++] = Math.round((dy + 1) * 127);
	    pixels[offset ++] = Math.round(( z + 1) * 127);
	    pixels[offset ++] = 0xff;
	}
    }

    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
}

function effectInit(gl, shader) {
    var texturesToLoad = 1;
    var textureWater;
    var textureNoise = makeNoiseTexture(gl);
    var textureWater = makeWaterTexture(gl);

    /* Bind the noise texture to texture unit 0. */
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textureNoise);
    gl.uniform1i(gl.getUniformLocation(shader, "uNoise"), 0);

    /* Bind the water map to texture unit 1.
     * If this doesn't work for some reason, we only
     * lose water waves... */
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textureWater);
    gl.uniform1i(gl.getUniformLocation(shader, "uWatermap"), 1);

    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Would Iñigo Quílez like it here?</h1>
<div>
<canvas id="canvas" width="768" height="768"></canvas>
</div>

<p>(If you can't see the effect live, <a href="landscape.png">a screenshot is here</a>)</p>

<p>Shown here is a 3D world rendered in fragment shader. There is no
triangle geometry of any kind. The world is rendered instead by a terrain
marching technique, where a distance field is iterated until a point in
world's surface has been reached.
</p>

<p>The distance field is approximated from a heightmap computed realtime
using modified fractional brownian motion similar to the formulation proposed by Quílez.
The terrain yielded this way is quite coarse; bump-mapping and other techniques
are used to fill in an illusion of large amount of detail.
</p>

<p>The soft shadows are calculated by a minimal terrain marcher that fires a ray
towards the Sun from the terrain point. If the ray passes through the terrain,
the point is counted to be in the shade, and the amount of ground over
the terrain-Sun ray then determines the extent of the soft shadowing. The sampling
is done at just 5 fixed points per pixel with the points distributed exponentially.
</p>

<p>The lighting equation is a modified version of Phong shading, where
soft shadows have been added that mask out the light contributions from the
specular and diffuse components.
</p>

<p>
The terrain types are derived from the following principles, using the knowledge of
point's height and surface normal:
</p>

<ul>
<li>The world is rock by default.</li>
<li>Sand is ground rock, water grinds rock into sand, and sand tends to flow downhill.
    Therefore sand exists close to water and where surface tilt is not very large.</li>
<li>Snow is wherever surface tilt is low and height is high. (Not in water!)</li>
</ul>

<p>The water surface is a sum of some 30 2D sin waves, rendered with aid of a
bumpmap calculated in JavaScript during effect's init. The surface is real in
sense that it actually has a height. The water is added during terrain marching:
if the ray enters a point that falls under the surface level of water at that point,
the ray is backtracked to the ray-water intersection using Newton-Raphson iteration.
The water is entirely colorless liquid, and its color is built from combination of
reflection, refraction and caustics. The refraction is not really properly calculated,
merely approximated.
</p>

<p>The sun is very bright&mdash;8 times brighter than the brightest color. There's a dynamic
exposure control that simulates iris if eye looks towards the Sun, and Sunlight turns progressively
redder as Sun leaves zenith.</p>

<p>Clouds are volumetric with help of a small raymarcher, although the cloud coloring is not realistic.
</p>

</body>
</html>
