<html><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><title>Landscape rendering experiment</title><script id="shader-fs" type="x-shader/x-fragment"> 
#ifdef GL_ES
precision highp float;
#endif

/* System's clock, for running animations. */
uniform float uTime;
/* Position of camera. */
uniform vec3 uPos;
/* Lookat of camera. */
uniform vec3 uDir;
/* Water texture */
uniform sampler2D uWatermap;
/* Noise texture */
uniform sampler2D uNoise;

/* Coordinates being currently rendered. */
varying vec2 vPosition;

/* How far to subdivide modified Perlin noise.
 * (Determines how coarse the terrain is.) */
const int MAPITERATIONS = 4;
/* Parameter for Quilez's noise generator. */
const float MAPSPIKES = 0.3;
/* How many march iterations per ray. */
const int RAYITERATIONS = 256;
/* Convert distance between ray and terrain position to "safe" advancing step. */
const float MARCH_SPEED = 0.5;
/* Level Of Detail: how far to render until dropping terrain features. */
const float LOD = 2.0;
/* When ray reaches close enough to terrain, stop marching */
const float STOPCONDITION = 0.0025;
/* Render distance. */
const float FOG = 5.;
/* Water level */
const float WATER_LEVEL = 0.4;
/* Water surface precision */
const int WATER_BISECTIONS = 4;
/* Direction to infinitely far-away Sun */
const vec3 SUN = vec3(0.9, 0., 0.45);
/* Sun's brightness. */
const float SUN_INTENSITY = 8.;
/* The camera up direction. */
const vec3 UP = vec3(0., 0., 1.);

const vec2 F2 = vec2(0.366025403784, 0.366025403784);
const vec2 G2 = vec2(0.211324865405, 0.211324865405);
const float ONE = 1./256.;

/* This function is based on the work of John Davis and Stefan Gustavson. */
vec3 simplex2d(in vec2 P) {
    vec2 Pi = P + dot(P, F2);
    Pi = floor(Pi);
    vec2 Pf0 = P - Pi + dot(Pi, G2);

    // For the 2D case, the simplex shape is an equilateral triangle.
    // Find out whether we are above or below the x=y diagonal to
    // determine which of the two triangles we're in.
    vec2 o1 = vec2(Pf0.x > Pf0.y, Pf0.x <= Pf0.y);

    /* Get simplex gradients. The texture
     * contains 4 values per pixel, the rg pair being
     * gradient at (0, 0) and ba pair being the gradient at (1, 1).
     */
    Pi += .5;
    vec4 grad02 = texture2D(uNoise, Pi * ONE) * 2.0 - 1.0;
    vec2 grad0 = grad02.rg;
    vec2 grad1 = texture2D(uNoise, (Pi + o1) * ONE).rg * 2.0 - 1.0;
    vec2 grad2 = grad02.ba;

    vec2 Pf1 = Pf0 - o1 + G2;
    vec2 Pf2 = Pf0 + 2.0 * G2 - 1.0;
    vec3 t = max(0.5 - vec3(dot(Pf0, Pf0), dot(Pf1, Pf1), dot(Pf2, Pf2)), 0.);
    vec3 t2 = t * t;
    vec3 t4 = t2 * t2;

    vec3 td = t * t2 * vec3(dot(grad0, Pf0), dot(grad1, Pf1), dot(grad2, Pf2));
    float dx = 8. * dot(td, vec3(Pf0.x, Pf1.x, Pf2.x)) - dot(t4, vec3(grad0.x, grad1.x, grad2.x));
    float dy = 8. * dot(td, vec3(Pf0.y, Pf1.y, Pf2.y)) - dot(t4, vec3(grad0.y, grad1.y, grad2.y));

    // Sum up and scale the result to cover the range [-.5,.5]
    return vec3(dot(td, t), dx, dy) * 70.;
}

/* Combine simplex noise to given octave.
 * Output: vec4(normalx, normaly, normalz, value) */
vec4 fbmPerlin2d(in vec2 pos, in int lastIteration) {
    float w = 0.5;
    vec3 o = vec3(w, 0., 0);
    for (int i = 0; i < 16; i ++) {
        o += w * simplex2d(pos);
        if (i == lastIteration) {
            break;
        }
        w *= .5;
        pos *= 2.;
    }
    
    return vec4(normalize(cross(vec3(-1., 0., o.y), vec3(0., -1., o.z))), o.x);
}

/* Combine simplex noise to given octave with enhancement by Inigo Quilez.
 * Output: vec4(normalx, normaly, normalz, value) */
vec4 fbmQuilez2d(in vec2 pos, in float spikiness, in int lastIteration) {
    float w = 0.5;
    vec3 o = vec3(w, 0., 0.);
    vec2 d = vec2(0., 0.);
    for (int i = 0; i < 16; i ++) {
        vec3 n = simplex2d(pos);
	d += n.yz * spikiness;
	float wf = w / (1. + dot(d, d));
        o += wf * n;
	if (i == lastIteration) {
	    break;
	}
        w *= .5;
        pos *= 2.;
    }

    return vec4(normalize(cross(vec3(-1., 0., o.y), vec3(0., -1., o.z))), o.x);
}

vec4 getWaterTexture(in vec3 pos) {
    vec4 wave1 = texture2D(uWatermap, pos.xy * 1.7 + vec2(uTime *.07, 0.));
    vec4 wave2 = texture2D(uWatermap, pos.xy + vec2(0., uTime *.11));
    return (wave1 - wave2) * .5;
}

/* Get water normal */
vec3 getWaterNormal(in vec3 pos) {
    vec2 waves = getWaterTexture(pos).xy;
    return vec3(waves, 1.0 - sqrt(dot(waves, waves)));
}

/* Get water level */
float getWaterLevel(in vec3 pos) {
    float ripple = getWaterTexture(pos).z;
    return WATER_LEVEL - ripple * .1;
}

/* Terrain marching.
 *
 * At each step along the way, the height of the ray from
 * ground is computed, and this is converted into a guesstimate
 * about a "safe" distance for ray to skip forwards.
 *
 * The octaves of Perlin noise that generates the landscape are
 * reduced if the ray appears to be far from the terrain, or
 * far from viewer.
 *
 * The stop condition also gets progressively coarser as
 * the ray gains distance to viewer. This should naturally "antialias"
 * the scenery at distance.
 *
 * Output: LOD value for terrain calculation.
 */
float intersectTerrain(inout vec3 pos, in vec3 dir) {
    /* Dynamic LOD during marching:
     * After distance to scene has been acquired, update LOD. */
    float t = 0.0;
    for (int i = 0; i < RAYITERATIONS; i ++) {
        float height = pos.z - fbmQuilez2d(pos.xy * .5, MAPSPIKES, MAPITERATIONS).w;
	
	/* There's a trick here. Our distance estimates are not conservative;
	 * if the ray steps into the terrain, height is negative, and the ray will
         * backtrack automatically. */
        float distanceEstimate = height * MARCH_SPEED;
        t += distanceEstimate;
        pos += distanceEstimate * dir;

        if (t > FOG) {
	    t = FOG;
	    break;
        }

	float waterLevel = getWaterLevel(pos);
	if (pos.z < waterLevel) {
	    /* underwater; find intersection point. */

	    /* Initial brackets: earlier iteration was above,
	     * this one is below. Therefore, there must be an
	     * intersection point. */
	    float b = t;
	    float a = t - distanceEstimate;

	    for (int i = 0; i < WATER_BISECTIONS; i ++) {
		/* Estimate distance to water. */
		float underwaterLength = (waterLevel - pos.z) / dir.z;
		float t2 = t + underwaterLength;

		/* Is the new root outside the established brackets? */
		if (t2 < a || t2 > b) {
		    /* Try again at range midpoint. */
		    waterLevel = getWaterLevel(pos);
		    t2 = (a + b) * .5;
		}

		pos += dir * (t2 - t);
		t = t2;
		waterLevel = getWaterLevel(pos);
		
		/* Discover root brackets as we go. */
		if (waterLevel < pos.z) {
		    a = t;
		} else {
		    b = t;
		}

	    }
	    
	    pos.z = waterLevel;
	    break;
	}

        /* Are we close enough to terrain? */
	float absHeight = abs(height);
        if (absHeight < STOPCONDITION * t) {
	    pos.z = fbmQuilez2d(pos.xy * .5, MAPSPIKES, MAPITERATIONS).w;
	    break;
        }

    }

    return t;
}

/* Minimal raymarcher that attempts to discover a point's shading.
 * Output: lighting factor
 */
float calculateShade(in vec3 pos) {
    /* add shadow: use sampling in an attempt of trying to find out the
     * maximum amount the ray from terrain point to sun is goes under terrain. */
    float shadow = 0.;
    float t = 0.01;
    for (int i = 0; i < 5; i ++) {
	/* Positive -> above ground. */
	vec3 testpos = pos + SUN * t;
	float rayHeight = testpos.z - fbmQuilez2d(testpos.xy * .5, MAPSPIKES, MAPITERATIONS).w;
	float inShadow = rayHeight / t - .1;
	if (inShadow < 0.) {
	    shadow += inShadow;
	}
	t *= 2.;
    }
    return smoothstep(-0.5, 0., shadow);
}

/* Evaluate rules to find color of terrain point.
 * Output: RGB. */
vec3 getTerrainColor(in vec3 pos, in vec3 dir) {
    /* Get surface properties. */
    vec3 normal = fbmQuilez2d(pos.xy * .5, MAPSPIKES, MAPITERATIONS).xyz;
    vec4 noise = fbmQuilez2d(pos.xy * 8., 1.0, 12);

    /* Tilt the coarse surface with detail texture. */
    normal = normalize(normal + noise.xyz * noise.w);
    
    /* Determine terrain type. */
    float overWater = smoothstep(WATER_LEVEL, WATER_LEVEL + 0.1, pos.z);
    float sandOrRock = smoothstep(0.84, 0.8, normal.z - pos.z * .25 - overWater);
    float rockOrSnow = smoothstep(1.0, 1.02, normal.z + pos.z * .1) * overWater;

    /* Sand texture */
    vec4 terrain = vec4(1.0, 1.0, 0.6, 0.) * pos.z;

    /* Rock texture */
    vec4 rockNoise = fbmPerlin2d(pos.xy * 512., 1);
    vec4 rockTexture = vec4(.2, .16, .10, 0.) * sqrt(noise.w);
    rockTexture += vec4(.1, .05, .02, 0.02) * rockNoise.w * rockNoise.w;
    terrain = mix(terrain, rockTexture, sandOrRock);
    normal = mix(normal, rockNoise.xyz,  sandOrRock * (1. - rockOrSnow) * .1);

    /* Snow -- height increased if terrain is not flat. */
    terrain = mix(terrain, vec4(1.4, 1.4, 1.4, .5), rockOrSnow);
   
    /* Foliage: if not under water, or above snow line, and terrain tilt is suitable. */
    /*float foliage =
	step(WATER_LEVEL, pos.z + normal.z * .1 - .05)
	* step(0.8, normal.z)
	* (1. - smoothstep(1.4, 1.5, pos.z + normal.z));
    vec4 grass = vec4(0.1, 0.2, 0.00, 0.);
    terrain = mix(terrain, grass, foliage);*/

    /* Apply lighting */
    normal = normalize(normal);
    vec3 reflection = reflect(SUN, normal);
    float diffuse = max(dot(normal, SUN), 0.0);
    float specular = max(dot(reflection, dir), 0.);
    float shade = calculateShade(pos);

    /* Modified Phong shading. The ambient level is fixed at .1.
     * The shadow masks out diffuse and the specular component. */
    return terrain.xyz * (.1 + diffuse * shade)
	 + shade * SUN_INTENSITY * terrain.w * pow(specular, 20.);
}

/* Render sky.
 * Output: RGB.
 */
vec3 getSkyColor(in vec3 pos, in vec3 dir) {
    float sunAngle = max(dot(dir, SUN), 0.);
    float sunDisc = pow(sunAngle, 40.);
    float skyBrightness = clamp(1. - dir.z, 0., 1.);

    float cloudTotal = 0.;
    for (int ix = 0; ix < 5; ix ++) {
	float i = 30. / (15. + float(ix));
	vec2 cloudCoord = pos.xy + 8. * vec2(i, i * i);
	float t = (i - pos.z) / dir.z;
	float clouds = fbmPerlin2d(cloudCoord + dir.xy * t, 2).w;
	clouds = smoothstep(0.4, 0.9, clouds);
	cloudTotal += clouds * dir.z;
    }
    cloudTotal = clamp(cloudTotal * .06, 0., 1.);

    vec3 skyColor = vec3(skyBrightness, skyBrightness, 1.) * .8;

    return mix(skyColor, vec3(1., 1., 1.) * SUN_INTENSITY, cloudTotal)
	+ SUN_INTENSITY * sunDisc;
}

/* Add distance fog to color.
 * Output: RGB.
 */
vec3 applyFog(in vec3 color, in float distance) {
    distance /= FOG;
    return mix(color, vec3(.8, .8, .8), distance*distance);
}

/* Calculate water color based on reflection and refraction.
 * Output: RGB.
 */
vec3 getWaterColor(in vec3 pos, in vec3 dir) {
    vec3 normal = getWaterNormal(pos);

    /* Fresnel equation approximation */
    float reflectionOrRefraction = max(-dot(dir, normal), 0.);
    reflectionOrRefraction = sqrt(reflectionOrRefraction);

    /* Reflect scenery */
    vec3 reflectionPos = pos;
    vec3 reflection = reflect(dir, normal);
    float reflectionLength = intersectTerrain(reflectionPos, reflection);
    vec3 reflectedTerrain = getTerrainColor(reflectionPos, reflection);

    /* Add sky */
    if (reflectionLength / FOG == 1.) {
	reflectedTerrain = getSkyColor(pos, reflection);
    } else {
	reflectedTerrain = applyFog(reflectedTerrain, reflectionLength);
    }

    /* Refract scenery (utterly fake). */
    float waterDepth = getWaterLevel(pos) - fbmQuilez2d(pos.xy * .5, MAPSPIKES, MAPITERATIONS).w;
    pos.xy += refract(dir, normal, 0.7).xy * waterDepth;
    pos.z = fbmQuilez2d(pos.xy * .5, MAPSPIKES, MAPITERATIONS).w;
    vec3 refractedTerrain = getTerrainColor(pos, normal);
    /* Caustics */
    refractedTerrain *= 1. + waterDepth * pow(1.0 + normal.x - normal.y, 20.);

    return mix(reflectedTerrain, refractedTerrain, reflectionOrRefraction);
}
    
/* Cross product. */
vec3 cross(in vec3 a, in vec3 b) {
    return a.yzx * b.zxy - a.zxy * b.yzx;
}

void main(void) {
    //gl_FragColor = texture2D(uNoise, vPosition * 4.);
    //gl_FragColor = texture2D(uWatermap, vPosition * 4.);
    //gl_FragColor = vec4(fbmPerlin2d(vPosition, 8).w * vec3(1., 1., 1.), 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmPerlin2d(vPosition*4., 8).xyz, 1.);
    //gl_FragColor = vec4(fbmQuilez2d(vPosition * 4., 8).w * vec3(1., 1., 1.) * .5, 1.);
    //gl_FragColor = vec4(vec3(.5, .5, .5) + .5 * fbmQuilez2d(vPosition*4., 8).xyz * .5, 1.);
    //return;

    /* Calculate position of camera. */
    float groundHeight = fbmQuilez2d(uPos.xy * .5, MAPSPIKES, MAPITERATIONS).w;
    if (groundHeight < WATER_LEVEL) {
	groundHeight = WATER_LEVEL;
    }
    vec3 cameraPos = vec3(uPos.xy, groundHeight + pow(2., -4.));
    
    /* Calculate an orthonormal basis based on lookat and up vector. */
    vec3 left = normalize(cross(UP, uDir));
    vec3 up = cross(uDir, left);
    vec3 dir = uDir + vPosition.x * left + vPosition.y * up;
    dir = normalize(dir);
    
    /* Terrain march. */
    vec3 terrainPos = cameraPos;
    float distance = intersectTerrain(terrainPos, dir);
    float waterLevel = getWaterLevel(terrainPos);

    /* Blend water if under water level. */
    vec3 terrain;
    if (terrainPos.z == waterLevel) {
	terrain = getWaterColor(terrainPos, dir);
    } else {
	terrain = getTerrainColor(terrainPos, dir);
    }

    if (distance / FOG == 1.) {
	terrain = getSkyColor(cameraPos, dir);
    } else {
	terrain = applyFog(terrain, distance);
    }

    float exposureControl = 1. - max(dot(uDir, SUN), 0.) * (1. - 1./SUN_INTENSITY);
    gl_FragColor = vec4(sqrt(terrain * exposureControl), 1);
}
</script> 

<script id="shader-vs" type="x-shader/x-vertex"> 
attribute vec3 aVertexPosition;

varying vec2 vPosition;

void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
    vPosition = gl_Position.xy;
}
</script> 

<script type="text/javascript" src="webgl.js"></script>
<script type="text/javascript">

function prng(n) {
    n = 12321 * n + 33323 & 0xffff;
    for (var i = 0; i < 2; i ++) {
	n &= 0xffff;
	n += n * n;
	n ^= n >> 7;
    }

    return n & 0xffff;
}

function makeNoiseTexture(gl) {
    var perm = [];
    for (var i = 0; i < 256 ; i ++) {
	perm.push(prng(i));
    }

    var pixels = new Uint8Array(256 * 256 * 4);
    var offset = 0;
    for (var i = 0; i < 256; i++) {
	for (var j = 0; j < 256; j++) {
	    var v1 = perm[j + perm[i] & 0xff];
	    var v2 = perm[j + 1 + perm[i + 1 & 0xff] & 0xff];
	    pixels[offset ++] = v1 & 0xff;
	    pixels[offset ++] = v1 >> 8;
	    pixels[offset ++] = v2 & 0xff;
	    pixels[offset ++] = v2 >> 8;
	}
    }
    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    return texture;
}

function makeWaterTexture(gl) {
    var waveParams = [];
    for (var wave = 0; wave < 20; wave ++) {
	var wp = prng(wave);
	waveParams.push([wp & 0xf, (wp >> 4) & 0xf, (wp >> 8) & 0xf, (1 + (wp >> 12) & 0xf) / 16 / 30]);
    }

    var pixels = new Uint8Array(512 * 512 * 4);
    var offset = 0;
    for (var i = 0; i < 512; i++) {
	var ifact = 2 * Math.PI * i / 512;
	for (var j = 0; j < 512; j++) {
	    var jfact = 2 * Math.PI * j / 512;

	    var dx = 0;
	    var dy = 0;
	    var z = 0;
	    for (var wave = 0; wave < waveParams.length; wave ++) {
		var pa = waveParams[wave];
		var phase = ifact * pa[0] + jfact * pa[1] + pa[2];
		dx += Math.sin(phase) * pa[3];
		dy += Math.cos(phase) * pa[3];
	    }

	    var z = dx - dy;
	    pixels[offset ++] = Math.round((dx + 1) * 127);
	    pixels[offset ++] = Math.round((dy + 1) * 127);
	    pixels[offset ++] = Math.round(( z + 1) * 127);
	    pixels[offset ++] = 0xff;
	}
    }

    var texture = gl.createTexture();
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
}

function effectInit(gl, shader) {
    var texturesToLoad = 1;
    var textureWater;
    var textureNoise = makeNoiseTexture(gl);
    var textureWater = makeWaterTexture(gl);

    /* Bind the noise texture to texture unit 0. */
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textureNoise);
    gl.uniform1i(gl.getUniformLocation(shader, "uNoise"), 0);

    /* Bind the water map to texture unit 1.
     * If this doesn't work for some reason, we only
     * lose water waves... */
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textureWater);
    gl.uniform1i(gl.getUniformLocation(shader, "uWatermap"), 1);

    effectStart(gl, shader);
}
</script>
</head>
<body>

<h1>Would IÃ±igo Quilez like it here?</h1>
<div>
<canvas id="canvas" width="512" height="512"></canvas>
</div>

<p>(If you can't see the effect live, <a href="landscape.png">a screenshot is here</a>)</p>

<p>Shown here is a 3D world rendered in fragment shader. There is no
triangle geometry of any kind. The world is rendered instead by a terrain
marching technique, where a distance field is iterated until a point in
world's surface has been reached.
</p>

<p>The distance field is approximated from a heightmap computed realtime
using modified fractional brownian motion similar to the formulation proposed by Quilez.
The terrain yielded this way is quite coarse; bump-mapping and other techniques
are used to fill in an illusion of large amount of detail.
</p>

<p>The soft shadows are calculated by a minimal terrain marcher that fires a ray
towards the Sun from the terrain point. If the ray passes through the terrain,
the point is counted to be in the shade, and the amount of ground over
the terrain-Sun ray then determines the extent of the soft shadowing. The sampling
is done at just 5 fixed points per pixel with the points distributed exponentially.
</p>

<p>The lighting equation is a modified version of Phong shading, where
soft shadows have been added that mask out the light contributions from the
specular and diffuse components.
</p>

<p>
The terrain types are derived from the following principles, using the knowledge of
point's height and surface normal:
</p>

<ul>
<li>The world is rock by default.</li>
<li>Sand is ground rock, water grinds rock into sand, and sand tends to flow downhill.
    Therefore sand exists close to water and where surface tilt is not very large.</li>
<li>Snow is wherever surface tilt is low and height is high. (Not in water!)</li>
</ul>

<p>The water surface is a sum of some 30 2D sin waves, rendered with aid of a
bumpmap calculated in JavaScript during effect's init. The surface is real in
sense that it actually has a height. The water is added during terrain marching:
if the ray enters a point that falls under the surface level of water at that point,
the ray is backtracked to the ray-water intersection using Newton-Raphson iteration.
The water is entirely colorless liquid, and its color is built from combination of
reflection, refraction and caustics. The refraction is not really properly calculated,
merely approximated.
</p>

<p>The sun is very bright&mdash;8 times brighter than the brightest color. There's a dynamic
exposure control that simulates iris if eye looks towards the Sun.</p>

<p>Clouds are faked volumetric from number of stacked noise layers.</p>

</body>
</html>
